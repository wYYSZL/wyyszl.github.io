<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>珂朵莉树 | wYYSZL 的博客</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://wyyszl.github.io/favicon.ico?v=1611279941322">
<link rel="stylesheet" href="https://wyyszl.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="一，名字由来
在太阳西斜的这个世界里
置身天上之森
等这场战争结束之后
不归之人与
望眼欲穿的众人
人人本着正义之名
长存不灭的过去
逐渐消逝的未来
我回来了
纵使日薄西山
即便看不到未来
此时此刻的光辉
盼君勿忘
——世界上最幸福的女孩：..." />
    <meta name="keywords" content="珂朵莉树" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://wyyszl.github.io">
        <img src="https://wyyszl.github.io/images/avatar.png?v=1611279941322" class="site-logo">
        <h1 class="site-title">wYYSZL 的博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      祝大家 csp ++score and  ++rp！
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/wYYSZL/wyyszl.github.io">wYYSZL</a> | <a class="rss" href="https://wyyszl.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">珂朵莉树</h2>
            <div class="post-date">2021-01-21</div>
            
            <div class="post-content" v-pre>
              <h2 id="一名字由来">一，名字由来</h2>
<p>在太阳西斜的这个世界里<br>
置身天上之森<br>
等这场战争结束之后<br>
不归之人与<br>
望眼欲穿的众人</p>
<p>人人本着正义之名<br>
长存不灭的过去<br>
逐渐消逝的未来<br>
我回来了<br>
纵使日薄西山<br>
即便看不到未来<br>
此时此刻的光辉<br>
盼君勿忘</p>
<p>——世界上最幸福的女孩：珂朵莉</p>
<p>“珂朵莉”是动漫《末日时在干什么？有没有空？可以来拯救吗？》的主人公。</p>
<p>一个关于爱情，牺牲，救赎的悲剧动漫的主人公。</p>
<p><s>闲扯一句：最近很闲，看了看那动漫，感觉好酸啊，酸完后又让人很哀伤</s>—— 不过那写（拍）得真的很好。</p>
<p>扯回来，至于为什么以主人公为名，说法不一。</p>
<p>我比较认同的是说有一道题：<a href="https://www.luogu.com.cn/problem/CF896C">CF896C</a>，有位 OIer 用此题发明了一个算法，此题背景有关珂朵莉，而此人又是珂朵莉迷，因而命名为珂朵莉树。</p>
<p>他也使 OI 与 珂朵莉 联系起来。。。</p>
<p>事实上，珂朵莉树是一个“野”算法，即它不像其他算法是被各界承认的。</p>
<p>但它有其作用。</p>
<h2 id="二-它可以干什么">二、它可以干什么</h2>
<p>很简单，在具有区间赋值操作，区间统计操作，以及最好保证<strong>数据随机</strong>的情况下在时空复杂度上把线段树吊起来打（详情见后）。<br>
也可以在走投无路时 <strong>骗分</strong>。</p>
<h2 id="三-你需要有哪些前置知识">三、你需要有哪些前置知识</h2>
<ul>
<li>五分钟就能学会的C++STL中set的部分内容</li>
<li>暴力枚举</li>
<li>数学知识（如果你想证明它的玄学复杂度的话）</li>
</ul>
<h2 id="四-实现">四、实现</h2>
<h3 id="各种声明以及初始化">各种声明以及初始化</h3>
<h4 id="珂朵莉树的节点">珂朵莉树的节点</h4>
<pre><code>typedef bool type;

struct Node
{
	unsigned int l;
	unsigned int r;
	mutable type data;
	Node(unsigned int a, unsigned int b = 0, type c = 0);
	bool operator &lt;(const Node &amp;a) const
	{
		return l &lt; a.l;
	}
};

Node::Node(unsigned int a, unsigned int b, type c)
{
 l = a;
 r = b;
 data = c;
}
</code></pre>
<p>解释一下上面的代码。</p>
<ul>
<li>珂朵莉树的每一个节点代表着一个闭区间，那么Node结构体里理应有这个区间的左右边界（即l和r）。</li>
<li>type和data是当前区间统一的类型与数值，就是说闭区间[l,r]内每个点的类型都是type（自己定义的，这里我使用了bool作为type，到底是什么无所谓），值都是data。（当然，我们只考虑离散的点）</li>
<li>data需要mutable修饰，这样我们可以在set中利用迭代器修改它。</li>
<li>对于结构体，我们自然需要构造函数，无需多讲。</li>
<li>由于我们使用set来存储Node，所以我们需要重载小于号，使其按照左端点排序。</li>
</ul>
<h4 id="构造珂朵莉树">构造珂朵莉树</h4>
<pre><code>#include &lt;set&gt;
set&lt;Node&gt; s;
</code></pre>
<p><s>没错这就完事了</s></p>
<p>就这么简单，你得到了一个没有初始化的珂朵莉树。</p>
<p>一般来说，我们通过给定数据，向其中不断插入区间长度为1的区间来完成初始化。</p>
<p>比如形如这样的话：“第二行包括n个数，表示序列的初始状态”（摘自SCOI2010 序列操作）。</p>
<p>我们就可以这样初始化：</p>
<pre><code>for (int i = 0; i &lt; n; ++i)
 {
 	static type temp = 0;
 	cin &gt;&gt; temp;
 	s.insert(Node(i, i, temp));
 }
 s.insert(Node(n, n, 0));
</code></pre>
<p>你的序列下标从0或者1开始是无所谓的。</p>
<p>这里有一个蜜汁细节，就是在把所有给定数据插入完成之后，需要在末尾多插入一个节点。我也不知道这究竟有啥用，根据自己测试貌似做不做这一步并没有什么区别，<s>反正是玄学，信就完事了。</s></p>
<h4 id="懒人宏定义">懒人宏定义</h4>
<p>我个人并不是很懒，但是声明迭代器真的很令人痛苦。于是我选择了这样</p>
<pre><code>#define S_IT set&lt;Node&gt;::iterator	//S_IT = set_iterator
</code></pre>
<p>据我所知，这个宏定义是大部分写珂朵莉树的OIer都选择了的。</p>
<p>你也可以自己搞一些更懒的宏定义。</p>
<p>至此，准备工作结束。</p>
<h3 id="核心操作">核心操作</h3>
<h4 id="分裂split">分裂：split</h4>
<p>既然我们要进行区间操作，那就得把这个区间拿出来（就是这么暴力的思想） 。<br>
split(pos)操作将包含位置pos的区间[l,r]分裂成[l,pos-1]和[pos,r]，并返回后者的迭代器。</p>
<pre><code>S_IT split(unsigned int pos)
{
 S_IT it = s.lower_bound(Node(pos));
 if (it != s.end() &amp;&amp; it-&gt;l == pos)
  return it;
 --it;
 unsigned int l = it-&gt;l, r = it-&gt;r;
 type data = it-&gt;data;
 s.erase(it);
 s.insert(Node(l, pos - 1, data));
 return s.insert(Node(pos, r, data)).first;
}
</code></pre>
<p>我们先利用lower_bound()函数在set中查到左端点位置大于等于pos的节点。</p>
<p>如果这个节点的左端点位置正是pos，那么我们无需分裂，直接返回。</p>
<p>如果它的左端点位置不是pos，那么必然大于pos，则包含位置pos的节点是上一个节点，it-=1。</p>
<p>接下来的事情就好办了，暴力分裂再插入即可。不要忘了返回值。</p>
<p>此时，如果我们想使用区间[l,r]中的数据，只需要这么写：</p>
<pre><code>S_IT it2 = split(r + 1), it1 = split(l);
 for (; it1 != it2; ++it1)
 {
  ；	//利用迭代器it1搞些事情
 }
</code></pre>
<p>这里有一个细节必须注意，必须先声明it2再声明it1，否则根据split中的erase操作，迭代器it1可能会失效。（因为it1所属的节点可能被删除了）</p>
<h4 id="区间赋值assign">区间赋值：assign</h4>
<p>珂朵莉树最重要的操作，也是不让它退化为暴力算法的玄学 保障。</p>
<p>既然一个区间内所有的值全都一样了，那么在珂朵莉树中这个区间就可以只用一个节点来表示。这就是珂朵莉树的核心，光速降低节点数量的神器。</p>
<pre><code>void assign(unsigned int l, unsigned int r, type val)
{
 S_IT it2 = split(r + 1), it1 = split(l);
 s.erase(it1, it2);
 s.insert(Node(l, r, val));
 return;
}
</code></pre>
<p>可见，这个区间里所有的节点全部被删除，使用一个新的节点来代替。</p>
<p>根据我并不会的 证明，assign的区间长度在随机数据下的期望为N/3，十分恐怖。</p>
<p>而且这个assign在赋值之余还可以顺便做做区间统计啥的，根据情况而定</p>
<p>至此，珂朵莉树的核心操作介绍完毕。</p>
<p>附加的工作？<br>
很多时候，一道题不可能只用两个函数就轻松搞定，需要额外的暴力函数与算法，是的就是暴力。</p>
<p>由于暴力算法大家肯定会，又怕大家不好理解，所以在这里贴一下大佬写的的CF896C的代码。</p>
<p>这道题虽说是起源，但是还是比较有难度的，认为太难的可以直接往下走，看另一个例子。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;vector&gt;

using namespace std;

#define S_IT set&lt;Node&gt;::iterator
typedef long long ll;

struct Node
{
	int l, r;
	mutable ll val;
	bool operator &lt;(const Node &amp;a) const
	{
		return l &lt; a.l;
	}
	Node(int a, int b, ll v);
	Node(int a);
};

S_IT split(int pos);
void add(int l, int r, int v);
ll kth(int l, int r, int k);
ll qpow(ll a, int b, ll y);
ll query(int l, int r, int x, ll y);
void assign(int l, int r, int v);
int rnd(void);

set&lt;Node&gt; s;
ll seed;
int n, m, vmax;

int main(void)
{
	ios::sync_with_stdio(false);
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; seed &gt;&gt; vmax;
	for (int i = 1; i &lt;= n; ++i)
	{
		static int temp = 0;
		temp = rnd() % vmax + 1;
		s.insert(Node(i, i, (ll)temp));
	}
	s.insert(Node(n + 1, n + 1, 0));
	for (int i = 1; i &lt;= m; ++i)
	{
		static int l = 0, r = 0, x = 0, y = 0, op = 0;
		op = rnd() % 4 + 1;
		l = rnd() % n + 1, r = rnd() % n + 1;
		if (l &gt; r)
		{
			swap(l, r);
		}
		if (op == 3)
		{
			x = rnd() % (r - l + 1) + 1;
		}
		else
		{
			x = rnd() % vmax + 1;
		}
		if (op == 4)
		{
			y = rnd() % vmax + 1;
		}
		
		if (op == 1)
		{
			add(l, r, (ll)x);
		}
		else if (op == 2)
		{
			assign(l, r, (ll)x);
		}
		else if (op == 3)
		{
			cout &lt;&lt; kth(l, r, x) &lt;&lt; endl;
		}
		else if (op == 4)
		{
			cout &lt;&lt; query(l, r, x, (ll)y) &lt;&lt; endl;
		}
	}
	//system(&quot;pause&quot;);
	return 0;
}

Node::Node(int a, int b, ll v)
{
	l = a;
	r = b;
	val = v;
}

Node::Node(int a)
{
	l = a;
}

S_IT split(int pos)
{
	S_IT it = s.lower_bound(Node(pos));
	if (it != s.end() &amp;&amp; it-&gt;l == pos)
	{
		return it;
	}
	--it;
	int l = it-&gt;l, r = it-&gt;r;
	ll val = it-&gt;val;
	s.erase(it);
	s.insert(Node(l, pos - 1, val));
	return s.insert(Node(pos, r, val)).first;
}

void add(int l, int r, int v)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	for (S_IT it=it1; it != it2; ++it)
	{
		it-&gt;val += v;
	}
}

ll kth(int l, int r, int k)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	vector&lt;pair&lt;ll, int&gt; &gt;arr;
	arr.clear();
	for (S_IT it = it1; it != it2; ++it)
	{
		arr.push_back(pair&lt;ll, int&gt;(it-&gt;val, it-&gt;r - it-&gt;l + 1));
	}
	sort(arr.begin(), arr.end());
	for (unsigned int i = 0; i &lt; arr.size(); ++i)
	{
		k -= arr[i].second;
		if (k &lt;= 0)
		{
			return arr[i].first;
		}
	}
}

ll qpow(ll a, int x, ll y)
{
	ll b = 1LL;
	a %= y;
	while (x)
	{
		if (x &amp; 1)
		{
			b = (b*a) % y;
		}
		a = (a*a) % y;
		x &gt;&gt;= 1;
	}
	return b;
}

ll query(int l, int r, int x, ll y)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	ll res = 0;
	for (S_IT it = it1; it != it2; ++it)
	{
		res = (res + (it-&gt;r - it-&gt;l + 1)*qpow(it-&gt;val, x, y)) % y;
	}
	return res;
}

void assign(int l, int r, int v)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	s.erase(it1, it2);
	s.insert(Node(l, r, v));
}

int rnd(void) 
{
	int ret = (int)seed;
	seed = (seed * 7 + 13) % 1000000007;
	return ret;
}
</code></pre>
<p>SCOI2010 序列操作也是可以用珂朵莉树暴力写出来的一道题，尽管数据不随机。</p>
<p>这道题相比之下简单一些额外的操作较少，各个函数也比较容易理解。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;

using namespace std;

#define S_IT set&lt;Node&gt;::iterator
#define MAXN 100002
typedef long long ll;
typedef bool type;

struct Node
{
	unsigned int l;
	unsigned int r;
	mutable type data;
	Node(unsigned int a, unsigned int b = 0, type c = 0);
	bool operator &lt;(const Node &amp;a) const
	{
		return l &lt; a.l;
	}
};

S_IT split(unsigned int pos);
void assign(unsigned int l, unsigned int r, type val);
void rev(unsigned int l, unsigned int r);
int sum(unsigned int l, unsigned int r);
int count(unsigned int l, unsigned int r);

set&lt;Node&gt; s;

int main(void)
{
	ios::sync_with_stdio(false);
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; n; ++i)
	{
		static type temp = 0;
		cin &gt;&gt; temp;
		s.insert(Node(i, i, temp));
	}
	s.insert(Node(n, n, 0));
	while (m--)
	{
		static unsigned int op = 0, a = 0, b = 0;
		cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;
		if (op == 0)
		{
			assign(a, b, 0);
		}
		else if (op == 1)
		{
			assign(a, b, 1);
		}
		else if (op == 2)
		{
			rev(a, b);
		}
		else if (op == 3)
		{
			cout &lt;&lt; sum(a, b) &lt;&lt; endl;
		}
		else
		{
			cout &lt;&lt; count(a, b) &lt;&lt; endl;
		}
	}
	system(&quot;pause&quot;);
	return 0;
}

Node::Node(unsigned int a, unsigned int b, type c)
{
	l = a;
	r = b;
	data = c;
}

S_IT split(unsigned int pos)
{
	S_IT it = s.lower_bound(Node(pos));
	if (it != s.end() &amp;&amp; it-&gt;l == pos)
		return it;
	--it;
	unsigned int l = it-&gt;l, r = it-&gt;r;
	type data = it-&gt;data;
	s.erase(it);
	s.insert(Node(l, pos - 1, data));
	return s.insert(Node(pos, r, data)).first;
}

void assign(unsigned int l, unsigned int r, type val)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	s.erase(it1, it2);
	s.insert(Node(l, r, val));
	return;
}

void rev(unsigned int l, unsigned int r)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	for (; it1 != it2; ++it1)
	{
		it1-&gt;data ^= 1;
	}
}

int sum(unsigned int l, unsigned int r)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	int res = 0;
	for (; it1 != it2; ++it1)
	{
		res += it1-&gt;data ? it1-&gt;r - it1-&gt;l + 1 : 0;
	}
	return res;
}

int count(unsigned int l, unsigned int r)
{
	int res = 0, temp = 0;
	S_IT it2 = split(r + 1), it1 = split(l);
	for (; it1 != it2; ++it1)
	{
		if (it1-&gt;data)
		{
			temp += it1-&gt;r - it1-&gt;l + 1;

		}
		else
		{
			res = max(res, temp);
			temp = 0;
		}
	}
	return max(res, temp);	
}
</code></pre>
<p>最后的话</p>
<p>根据数学（玄）分析，珂朵莉树的各种操作的总体复杂度始终为O(NlogN)，这会吊打某些常数大，附加工作会影响总体复杂度的线段树算法。</p>
<p>举个例子，洛谷P2787，有两种写法，线段树和珂朵莉树。<br>
先看看一个ren（我并不认识）的线段树代码（注意右上角的耗时与内存）<br>
被吊打的线段树<br>
然后是我的珂朵莉树代码（我开了O2优化，不开的话用时增加0.5倍左右）。</p>
<p>在这里插入图片描述</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/2019080211051081.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NDX2RzbQ==,size_16,color_FFFFFF,t_70" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20190802110643184.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NDX2RzbQ==,size_16,color_FFFFFF,t_70" alt="" loading="lazy"></figure>
<p>线段树被吊打。</p>
<p>至此，你大致了解完了珂朵莉树的全部基本操作。</p>
<h2 id="五-优缺点">五、优缺点</h2>
<p>1.珂朵莉树在某些情况下可以吊打线段树；柯朵丽树是目前唯一一个可以处理幂次方的树形算法；珂朵莉树可以骗分。</p>
<p>2.珂朵莉树的复杂度是极不稳定的，毕竟它是一个暴力操作，它依赖数据，只有在数据<strong>足够随机</strong>时才能达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi mathvariant="normal">（</mi><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">O（n log n）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">）</span></span></span></span></p>
<p>3.<s>还有一点，你在码珂朵莉树时可以调动您的文学细胞；您在码珂朵莉树时可能会感到有些哀伤不适</s></p>
<h2 id="六-题单">六、题单</h2>
<p>以下题目都珂以用珂朵莉树做，但珂朵莉树并不是正解，只是因为数据水才能过</p>
<ul>
<li>1.Luogu CF343D Water Tree</li>
<li>2.Luogu P2572 [SCOI2010]序列操作</li>
<li>3.Luogu P4344 [SHOI2015]脑洞治疗仪</li>
<li>4.Luogu CF915E Physical Education Lessons</li>
<li>5.Luogu P2787 语文1（chin1）- 理理思维</li>
<li>6.Luogu P1204 [USACO1.2]挤牛奶Milking Cows</li>
<li>7.Luogu P4979 矿洞：坍塌</li>
<li>8.Luogu P3740 [HAOI2014]贴海报</li>
</ul>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://wyyszl.github.io/tag/Heq9OOlWa/" class="tag">
                    珂朵莉树
                  </a>
                
              </div>
            
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
