<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wyyszl.github.io</id>
    <title>wYYSZL 的博客</title>
    <updated>2021-01-19T02:45:42.392Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wyyszl.github.io"/>
    <link rel="self" href="https://wyyszl.github.io/atom.xml"/>
    <subtitle>祝大家 csp ++score and  ++rp！</subtitle>
    <logo>https://wyyszl.github.io/images/avatar.png</logo>
    <icon>https://wyyszl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, wYYSZL 的博客</rights>
    <entry>
        <title type="html"><![CDATA[csp5020-2]]></title>
        <id>https://wyyszl.github.io/post/csp5020-2/</id>
        <link href="https://wyyszl.github.io/post/csp5020-2/">
        </link>
        <updated>2021-01-19T02:45:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="csp-j">csp-j</h1>
<h2 id="t1">t1</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
int i;
int n;
bool b[128];
inline void ini(int a){
	for(i=1;a;++i){
		b[i]=a%2;
		a&gt;&gt;=1;
	}
	return ;
}
int main(){
//	freopen(&quot;power.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;power.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;n;
	ini(n);
	if(b[1]){
		cout&lt;&lt;-1;
		return 0;
	}
	for(;i;--i){
		if(b[i])cout&lt;&lt;(int)pow(2,i-1)&lt;&lt;' ';
	}
	return 0;
}




</code></pre>
<h2 id="t2">t2</h2>
<h3 id="1">1</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
int n,last,l;
int w;
priority_queue&lt;int&gt;dl2;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;dl1;
int main(){
//	freopen(&quot;live.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;live.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;n&gt;&gt;w;
	cin&gt;&gt;l;
	last=l;
	dl1.push(l);
	cout&lt;&lt;l&lt;&lt;' ';
	for(int i=2;i&lt;=n;++i){
		scanf(&quot;%d&quot;,&amp;l);
		if(l&lt;last)dl2.push(l);
		else dl1.push(l);
		if((int)dl1.size()&lt;max(1,(int)(i*w/100.0))){
			int u=dl2.top();
			dl2.pop();
			dl1.push(u);
			last=dl1.top();
		}
		if((int)dl1.size()&gt;max(1,(int)(i*w/100.0))){
			int u=dl1.top();
			dl1.pop();
			dl2.push(u);
			last=dl1.top();
		}
		cout&lt;&lt;last&lt;&lt;' ';
	}
	return 0;
}



</code></pre>
<h3 id="2">2</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
int n,w;
int l;
struct Node {
	int l,r,sum;
} tree[2405];
void build(int t,int l,int r) {
	tree[t].l =l;
	tree[t].r =r;
	tree[t].sum =0;
	if(not(l-r))return ;
	int mid=(l+r)&gt;&gt;1;
	build(t*2,l,mid);
	build(t*2+1,mid+1,r);
	return;
}
void cnote(int t,int l){
	if(not(tree[t].l -tree[t].r )){
		++tree[t].sum;
		return ;
	}
	int mid=(tree[t].l +tree[t].r )&gt;&gt;1;
	if(l&lt;=mid)cnote(t*2,l);
	else cnote(t*2+1,l);
	++tree[t].sum ;
	return ;
}
int ask(int t,int l){
	if(not(tree[t].l -tree[t].r ))return tree[t].l ;
	if(tree[t*2+1].sum &gt;=l)return ask(t*2+1,l);
	else return ask(t*2,l-tree[t*2+1].sum );
}
int main() {
	ios::sync_with_stdio(0);
	cin&gt;&gt;n&gt;&gt;w;
	build(1,1,600);
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;l;
		cnote(1,l);
		int asdf=max(1,i*w/100);
		cout&lt;&lt;ask(1,asdf)&lt;&lt;' ';
	}
	return 0;
}

</code></pre>
<h3 id="3">3</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int t[605];
int n,w;
int main()
{
	int x;
	cin&gt;&gt;n&gt;&gt;w;
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;x;
		t[x]++;
		int sum=0;
		for(int j=600;j&gt;=0;j--)
		{
			sum+=t[j];
			if(sum&gt;=max(1,i*w/100))
			{
				cout&lt;&lt;j&lt;&lt;' ';
				break;
			}
		}
	}
	return 0;
 } 
</code></pre>
<h2 id="t3">t3</h2>
<h3 id="赛时30pts">赛时（30pts）</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
string s[100005];
int i;
int num;
int t[100005];
int len;
int l;
bool q[100005];
int z;
int  ans1,ans2;
int n;
int d[100005];
bool asdf;
stack&lt;int&gt;zh;
bool zjx[100005];
bool check(string s) {
	len=s.size();
	if(!s.size())return 1;
	for(int i=0; i&lt;len; ++i) {
		if(!(s[i]&gt;='0' &amp;&amp; s[i]&lt;='9'))return 1;
	}
	return 0;
}
int main() {
	q[100001]=1;
	q[100002]=0;
	while(++i,cin&gt;&gt;s[i],check(s[i])) {
		len=s[i].size();
		if(s[i]==&quot;&amp;&quot; || s[i]==&quot;|&quot;||s[i]==&quot;!&quot;) {
			char ch=s[i][0];
			switch(ch) {
				case'&amp;' : {
					t[++num]=-1;
					break;
				}
				case'|': {
					t[++num]=-2;
					break;
				}
				default: {
					t[++num]=-3;
					asdf=1;
					break;
				}
			}
		} else {
			l=0;
			for(int j=1; j&lt;len; ++j) {
				l*=10;
				l+=s[i][j]-'0';
			}
			t[++num]=l;
		}
	}
	for(int j=0; j&lt;s[i].size(); ++j) {
		n*=10;
		n+=s[i][j]-'0';
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;q[i];
	}
	for(int j=1; j&lt;=num; ++j) {
		if(t[j]&gt;0) {
			zh.push(t[j]);
		} else {
			if(t[j]&gt;=-2) {
				ans1=zh.top();
				zh.pop();
				ans2=zh.top();
				zh.pop();
			} else {
				ans1=zh.top();
				zh.pop();
			}
			switch(t[j]) {
				case -1 : {
					if(q[ans1] &amp; q[ans2])zjx[ans1]=zjx[ans2]=1;
					if(q[ans1] &amp; !q[ans2])zjx[ans2]=1;
					if(q[ans2] &amp;!q[ans1])zjx[ans1]=1;
					ans1=((q[ans1] &amp;q[ans2])?100001:100002);
					
					break;
				}
				case -2 : {
					if(q[ans1] &amp;q[ ans2])zjx[ans1]=zjx[ans2]=0;
					else if(q[ans1]&amp; !q[ans2])zjx[ans1]=1;
					else if(q[ans2]&amp; !q[ans1])zjx[ans2]=1;
					ans1=((q[ans1 ]| q[ans2])?100001:100002);

					break;
				}
				default: {
					ans1=ans1;
					if(ans1!=100001 and ans1!=100002)q[ans1]=!q[ans1];
					else ans1=(ans1==100001?100002 :100001);
					break;
				}
			}
			zh.push(ans1);
		}
	}
	int djx=q[zh.top()];
	cin&gt;&gt;z;
	for(int i=1;i&lt;=n;++i)cout&lt;&lt;zjx[i]&lt;&lt;' ';
	for(int i=1; i&lt;=z; ++i) {
		cin&gt;&gt;l;
		if(zjx[l])cout&lt;&lt;(!djx)&lt;&lt;endl;
		else cout&lt;&lt;djx&lt;&lt;endl;
	}
	return 0;
}
// Ta&amp;Shan?Zhi@Shi%
</code></pre>
<h3 id="赛后">赛后</h3>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int INF = 0x3f3f3f3f;
const LL mod = 1e9 + 7;
const int N = 1000005;

char s[N];
int a[N];
int son[N][2], ck;
int flag[N], c[N];
int n, q;
int dfs(int u, int g) {
    a[u] ^= g;
    if (u &lt;= n) {
        return a[u];
    }
    int x = dfs(son[u][0], g ^ flag[son[u][0]]);
    int y = dfs(son[u][1], g ^ flag[son[u][1]]);
    if (a[u] == 2) {
        if (x == 0) c[son[u][1]] = 1;
        if (y == 0) c[son[u][0]] = 1;
        return x &amp; y;
    } else {
        if (x == 1) c[son[u][1]] = 1;
        if (y == 1) c[son[u][0]] = 1;
        return x | y;
    }
}
void dfs2(int u) {
    if (u &lt;= n) return;
    c[son[u][0]] |= c[u];
    c[son[u][1]] |= c[u];
    dfs2(son[u][0]);
    dfs2(son[u][1]);
}
int main() {
    // freopen(&quot;expr.in&quot;, &quot;r&quot;, stdin);
    // freopen(&quot;expr.out&quot;, &quot;w&quot;, stdout);
    gets(s);
    scanf(&quot;%d&quot;, &amp;n);
    ck = n;
    for (int i = 1; i &lt;= n; i++) {
        scanf(&quot;%d&quot;, &amp;a[i]);
    }
    stack&lt;int&gt; b;
    for (int i = 0; s[i]; i += 2) {
        if (s[i] == 'x') {
            int x = 0;
            i++;
            while (s[i] != ' ') {
                x = x * 10 + s[i] - '0';
                i++;
            }
            i--;
            b.push(x);
        } else if (s[i] == '&amp;') {
            int x = b.top();
            b.pop();
            int y = b.top();
            b.pop();
            b.push(++ck);
            a[ck] = 2;
            son[ck][0] = x;
            son[ck][1] = y;
        } else if (s[i] == '|') {
            int x = b.top();
            b.pop();
            int y = b.top();
            b.pop();
            b.push(++ck);
            a[ck] = 3;
            son[ck][0] = x;
            son[ck][1] = y;
        } else if(s[i] == '!'){
            flag[b.top()] ^= 1;
        }
    }
    int ans = dfs(ck, flag[ck]);
    dfs2(ck);
    scanf(&quot;%d&quot;, &amp;q);
    while (q--) {
        int x;
        scanf(&quot;%d&quot;, &amp;x);
        printf(&quot;%d\n&quot;, c[x] ? ans : !ans);
    }
    return 0;
}
</code></pre>
<h2 id="t4">t4</h2>
<h3 id="赛时20pts">赛时（20pts）</h3>
<p><s>变量名很皮（都是大佬的名字）</s></p>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
int xty[1005][1005];
int zjx=-0x3f3f3f3f;
bool djx[1005][1005];
int n,m;
int jht;
void dfs(int zkx,int szq,int jht){
	if(zkx&lt;1 || zkx&gt;n ||szq&lt;1 ||szq&gt;m)return;
	if(djx[zkx][szq])return ;
	if(zkx==n &amp;&amp; szq==m){
		zjx=max(zjx,jht);
		return;
	}
	djx[zkx][szq]=1;
	dfs(zkx-1,szq,jht+xty[zkx-1][szq]);
	dfs(zkx+1,szq,jht+xty[zkx+1][szq]);
	dfs(zkx,szq+1,jht+xty[zkx][szq+1]);
	djx[zkx][szq]=0;
}
int main(){
//	freopen(&quot;number.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;number.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;++i){
		for(int j=1;j&lt;=m;++j){
			cin&gt;&gt;xty[i][j];
			if(xty[i][j]&gt;=0)jht+=xty[i][j];
		}
	}
	if(n*m&lt;=35)dfs(1,1,xty[1][1]);
	else{
		cout&lt;&lt;jht;
	}
	cout&lt;&lt;zjx;
	return 0;
}



</code></pre>
<h3 id="赛后-2">赛后：</h3>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
long long n,m,a[1002][1002];
long long f[1002][1002][3];
int main() {
	ios::sync_with_stdio(0);
	cin&gt;&gt;n&gt;&gt;m;
	memset(f,-0x3f,sizeof f);
	for (int i=1; i&lt;=n; ++i)
		for (int j=1; j&lt;=m; ++j) {
			cin&gt;&gt;a[i][j];
		}
	f[1][1][0]=a[1][1];
	for (int i=2; i&lt;=n; ++i) f[i][1][0]=f[i-1][1][0]+a[i][1];
	for (int j=2; j&lt;=m; ++j) {
		f[1][j][1]=f[1][j-1][0]+a[1][j];
		f[n][j][2]=f[n][j-1][0]+a[n][j];
		for (int i=2; i&lt;=n; ++i) {
			f[i][j][1]=max(f[i][j-1][0],f[i-1][j][1])+a[i][j];
		}
		for (int i= n-1; i&gt;0; i--){
			f[i][j][2]=max(f[i][j-1][0],f[i+1][j][2])+a[i][j];
		}
		for (int i=1; i&lt;=n; ++i){
			f[i][j][0]=max(f[i][j][1],f[i][j][2]);
		}
	}
	cout&lt;&lt;f[n][m][0];
	return 0;
}
</code></pre>
<h1 id="csp-s">csp-s</h1>
<h2 id="t1-2">t1</h2>
<h3 id="赛时70pts">赛时（70pts）</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
int T;
int n;
int day ,year,month;
int db[13]= {0,31,28,31,30,31,30,31,31,30,31,30,31};
inline bool check(int q) {
	if(q&gt;0) {
		if(q&gt;1582) {
			if(((q%4==0) &amp;&amp; q%100) || (q%400==0))return 1;
			else return 0;
		} else {
			if(!(q%4))return 1;
			else return 0;
		}
	}
	++q;
	q=-q;
	if(!(q%4))return 1;
	else return 0;
}
struct P {
	int y;
	short m,d;
} pf[10000006];
int main() {

// 	freopen(&quot;julian.in&quot;,&quot;r&quot;,stdin);
// 	freopen(&quot;julian.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;T;
	day=month=1;
	year=-4713;
	db[2]=29;
	for(int i=1; i&lt;=10000000; ++i) {
		++day;
		if(day&gt;db[month]) {
			++month;
			day=1;
		}
		if(month&gt;12) {
			++year;
			if(!year) {
				++year;
			}
			if(check(year))db[2]=29;
			else db[2]=28;
			month=1;
		}
		if(year==1582 &amp;&amp; month==10 &amp;&amp; day==5) {
			day=15;
		}
		pf[i].d =day;
		pf[i].m =month;
		pf[i].y =year;
	}
	while(T--) {
		scanf(&quot;%d&quot;,&amp;n);
		cout&lt;&lt;pf[n].d &lt;&lt;' '&lt;&lt;pf[n].m &lt;&lt;' '&lt;&lt;abs(pf[n].y )&lt;&lt;(pf[n].y &gt;0?&quot; &quot;:&quot; BC&quot;)&lt;&lt;endl;

	}



	return 0;
}


//(ke2YI0gong2YU0)

</code></pre>
<h3 id="赛后-3">赛后</h3>
<pre><code>include&lt;bits/stdc++.h&gt;
#define ll long long
#define int long long //重要 
#define gc getchar
using namespace std;
inline ll read(){
    ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}
    while (isdigit(ch)){x=x*10ll+ch-'0';ch=gc();}
    return x*f;
}
const int mon[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
const int rmon[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
struct que{
    int t,id;
}q[1010101];
struct QWQ{
    int y,m,d;
}ori,tmp,ans[101010],X[300001];
int Q,mx,cnt; 
inline bool cmp(que a,que b){return a.t&lt;b.t;}
inline int mabs(int x){return (x&gt;0?x:-x);}
inline bool isr(QWQ a){
    if (a.y&lt;0) return (-a.y-1)%4==0;
    if (a.y&gt;=1582) return a.y%400==0||(a.y%4==0&amp;&amp;a.y%100);
    if (a.y%4==0) return 1;
    return 0;
}
inline QWQ nextday(QWQ a){ //分类讨论 
    QWQ ans=a;
    if (a.y==1582){
        if (a.m==12&amp;&amp;a.d==31) ans.y++,ans.d=1,ans.m=1;
        else if (a.m==10&amp;&amp;a.d==4) ans.d=15;
        else if (a.d==mon[a.m]) ans.d=1,ans.m++;
        else ans.d++;
        return ans;
    }
    if (a.y==-1&amp;&amp;a.m==12&amp;&amp;a.d==31) ans.y=1,ans.d=1,ans.m=1;    
    else if (isr(a)){
        if (a.m==12&amp;&amp;a.d==31) ans.y++,ans.d=1,ans.m=1;
        else if (a.d==rmon[a.m]) ans.d=1,ans.m++;
        else ans.d++;
    }else{
        if (a.m==12&amp;&amp;a.d==31) ans.y++,ans.d=1,ans.m=1;
        else if (a.d==mon[a.m]) ans.d=1,ans.m++;
        else ans.d++;
    }
    return ans;
}
signed main(){
    ori.y=-4713,ori.m=1,ori.d=1,cnt=-1;
    Q=read();
    for (int i=1;i&lt;=Q;i++) q[i].id=i,q[i].t=read();
    sort(q+1,q+1+Q,cmp);
    tmp=ori;
    for (int i=1;i&lt;=Q;i++){
        if (q[i].t&gt;=2451545) break;
        mx=i; 
    }
    for (int i=1,now=0;i&lt;=mx;i++){
        for (;now!=q[i].t;now++) tmp=nextday(tmp);
        ans[q[i].id]=tmp;
    }
    tmp.d=1,tmp.m=1,tmp.y=2000;
    for (;tmp.y!=2400;) X[++cnt]=tmp,tmp=nextday(tmp);
    for (int i=mx+1;i&lt;=Q;i++){
        ans[q[i].id].d=X[(q[i].t-2451545)%146097].d;
        ans[q[i].id].m=X[(q[i].t-2451545)%146097].m;
        ans[q[i].id].y=X[(q[i].t-2451545)%146097].y+400*((q[i].t-2451545)/146097);
    }
    for (int i=1;i&lt;=Q;i++){
        printf(&quot;%lld %lld %lld&quot;,ans[i].d,ans[i].m,mabs(ans[i].y));
        if (ans[i].y&lt;0) printf(&quot; BC&quot;);
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>
<h2 id="t2-2">t2</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
#define ull unsigned long long 
using namespace std;
long long n,m,c,k,v,y,t;
ull p,x;
int b[105];
//int x,v,y,p,ans,b[105],t;
signed main(){
	scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;c,&amp;k);
	for(int i = 1; i &lt;= n; i++){
		scanf(&quot;%llu&quot;,&amp;x);
		p |= x;
	}
	for(int i = 1; i &lt;= m; i++){
		scanf(&quot;%lld%lld&quot;,&amp;v,&amp;y);
		b[v] = 1;
	}
	for(int i = 0; i &lt;= k-1; i++ )
		if(((p&gt;&gt;i) &amp; 1) || !b[i]) t++;
	if(t &lt;= 63) printf(&quot;%llu\n&quot;,(1ull &lt;&lt; t) - n);
	else{
		n == 0 ?puts(&quot;18446744073709551616&quot;):printf(&quot;%llu\n&quot;,(((1ull&lt;&lt;63) - 1) | (1ull &lt;&lt; 63)) - (ull)(n-1));
	}
	return 0;
}
</code></pre>
<h2 id="t3-2">t3</h2>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
inline ll read(){
	ll x=0,sign=0; char s=getchar();
	while(s&gt;'9'||s&lt;'0')sign|=s=='-',s=getchar();
	while(s&lt;='9'&amp;&amp;s&gt;='0')x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0',s=getchar();
	return sign?-x:x;
}

const int N=1e5+5;
const int mod=998244353;

int n,m,c,a[N],deg[N],func[N];
int tp[N],pos[N],val[N];
ll mu=1,mul[N],dp[N],add[N];
vector &lt;int&gt; e[N];
queue &lt;int&gt; q;

bool vis[N];
void dfs(int id){
	vis[id]=1,mul[id]=(tp[id]==2?val[id]:1);
	for(int it:e[id]){
		if(!vis[it])dfs(it);
		mul[id]=mul[id]*mul[it]%mod;
	}
}

int main(){
	n=read(); for(int i=1;i&lt;=n;i++)a[i]=read();
	m=read();
	for(int i=1;i&lt;=m;i++){
		tp[i]=read();
		if(tp[i]==1)pos[i]=read(),val[i]=read();
		else if(tp[i]==2)val[i]=read();
		else{
			c=read();
			while(c--){
				int to=read();
				e[i].push_back(to),deg[to]++;
			}
		}
	} c=read();
	for(int i=1;i&lt;=m;i++)if(!vis[i]&amp;&amp;!deg[i])dfs(i);
	for(int i=1;i&lt;=c;i++)func[i]=read();
	for(int i=c,f=func[i];i;i--,f=func[i]){
		if(tp[f]==1)dp[f]=(dp[f]+mu);
		else if(tp[f]==2)mu=mu*val[f]%mod;
		else dp[f]=(dp[f]+mu),mu=mu*mul[f]%mod;
	} for(int i=1;i&lt;=m;i++)if(!deg[i])q.push(i);
	while(!q.empty()){
		int t=q.front(); q.pop();
		if(tp[t]==1)add[pos[t]]=(add[pos[t]]+dp[t]*val[t])%mod;
		ll z=dp[t]; reverse(e[t].begin(),e[t].end());
		for(int p:e[t]){
			deg[p]--; if(!deg[p])q.push(p);
			dp[p]=(dp[p]+z)%mod,z=z*mul[p]%mod;
		}
	} for(int i=1;i&lt;=n;i++)cout&lt;&lt;(a[i]*mu+add[i])%mod&lt;&lt;&quot; &quot;;
	return 0;
}

</code></pre>
<h2 id="t4-2">t4</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;fstream&gt;
#include&lt;cmath&gt;
using namespace std;
#define pii pair&lt;int,int&gt;
#define mp(x,y) make_pair(x,y)
inline int read(){
	char ch=getchar();
	int res=0,f=1;
	for(;ch&lt;'0'||ch&gt;'9';ch=getchar())if(ch=='-')f=-1;
	for(;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())res=(res&lt;&lt;3)+(res&lt;&lt;1)+(ch-'0');
	return res*f;
}
const int MAXN=1e6+5,inf=1e9;
int t,n,a[MAXN];
pii q1[MAXN],q2[MAXN];//q1单调递增，q2单调递减
int l1,r1,l2,r2;//首尾指针
inline pii mx(){//取出最大值且弹出
	if(r1==l1)return q2[l2++];
	else if(r2==l2)return q1[--r1];
	else if(q2[l2]&gt;q1[r1-1])return q2[l2++];
	else return q1[--r1];
}
inline pii mn(){//取出最小值并弹出
	if(l1==r1)return q2[--r2];
	else if(r2==l2)return q1[l1++];
	else if(q2[r2-1]&lt;q1[l1])return q2[--r2];
	else return q1[l1++];
}
inline pii M_min(pii x,pii y){
	return x&lt;y?x:y;
}
inline void solve(){
	l1=r1=l2=r2=0;
	for(int i=1;i&lt;=n;++i)q1[r1++]=mp(a[i],i);//初始化
	int fl=0,cnt=0,alf=0;
	while(1){
		++cnt;//计数器，同时也是死掉的蛇数
		pii x=mn(),y=mx();
		pii z=M_min((l1&lt;r1?q1[l1]:mp(inf,-inf)),(l2&lt;r2?q2[r2-1]:mp(inf,-inf)));//再取出一个最小值
		y.first-=x.first;
		if(y&gt;z||cnt==n-1){//Case2和边界写一起了
			if(fl){
				printf(&quot;%d\n&quot;,n-(fl-(alf&amp;1)));//奇偶性
				return ;
			}
			if(cnt==n-1){
				printf(&quot;1\n&quot;);
				return ;
			}
			q2[r2++]=y;//压入队列
		}
		else {
			alf++;//记录层数
			if(!fl)fl=cnt;	//第一个开始“冒风险”的蛇的之前死了多少
			q2[r2++]=y;//压入队列
		}
	}
}
int main(){
	t=read()-1;
	n=read();
	for(int i=1;i&lt;=n;++i)a[i]=read();
	solve();
	while(t--){
		int k=read();
		for(int i=1,x;i&lt;=k;++i)x=read(),a[x]=read();
		solve();
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文言]]></title>
        <id>https://wyyszl.github.io/post/wen-yan/</id>
        <link href="https://wyyszl.github.io/post/wen-yan/">
        </link>
        <updated>2021-01-19T00:43:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础篇">基础篇</h1>
<h3 id="1-说在前面">1、说在前面</h3>
<p>现在，电脑编程技术日渐新颖。近日，一个文言文语言编程火遍了 github ，这里将会为你讲述如何编写文言文代码。</p>
<h3 id="2-关于wenyan语言的代码与语法">2、关于wenyan语言的代码与语法</h3>
<h4 id="2-1-认识wenyan语言">2-1、认识wenyan语言</h4>
<h5 id="hello-wenyan">Hello wenyan</h5>
<p>咱们都知道，学习一门编程语言是从什么开始的？？<br>
众编程 orz ：当然是 A+B 辣~<br>
哦，不对，学习一门语言应该先从理解这个语言的优缺点啊，基础框架啊等等（回想一下你刚开始学 C++ ，Pascal 的时候）。<br>
但是! wenyan 语言 没有框架！<br>
wenyan 就像 Pascal 一样，定义好变量后就直接开始打主代码了。不会像 C++ 一样还有什么万能头啊，什么 STL 啊，没有这么多,简单易懂（还能提升你的文言文阅读水平）。<br>
现在，我们要开始打主代码，我们先从最基本的 Hello world! 开始吧~<br>
wenyan 的 Helloworld! 的输出是这样的：</p>
<p><code>吾有一言。曰「「Hello world!」」。書之。</code></p>
<p>是不是很生动？很形象？对， wenyan 就是这样！清晰易懂，代码简便......<br>
现在开始介绍 wenyan 的基本语法:</p>
<h3 id="2-2-基本语法">2-2、基本语法</h3>
<h4 id="2-2-1-定义变量">2-2-1、定义变量</h4>
<p>毕竟都说是文言文编程了，肯定不能出现英文字母和数字的嘛~</p>
<p><strong>wenyan vs C++</strong></p>
<pre><code>吾有一數。曰六。名之曰「甲」。	int a（a就是甲）=6;
有數六。名之曰「蒟蒻」。	int juruo=6;
吾有一言。曰「「噫吁戲」」。名之曰「乙」。	string b（s就是乙）=alas!
</code></pre>
<h4 id="2-2-2-ture和false">2-2-2、ture和false</h4>
<p>true/false 分别对应 wenyan 语言中的陽/陰（繁体的阳/阴），类型就是“爻”（卦符的基本符号）：</p>
<p><strong>wenyan vs C++</strong></p>
<pre><code>吾有一爻。曰陽。名之曰「丙」。	bool c=true;
吾有一爻。曰陰。名之曰「丁」。	bool d=false;
</code></pre>
<h4 id="2-2-3-if判断">2-2-3、if判断</h4>
<p>作为一个编程语言怎么少了 if 判断呢？</p>
<p><strong>wenyan vs C++</strong></p>
<pre><code>若三不大於五者。吾有一言。曰「「OK」」。書之。。若非。乃得「「NO」」也。	if(3&lt;=5) cout&lt;&lt;&quot;OK&quot;; else cout&lt;&lt;&quot;NO&quot;;
</code></pre>
<h4 id="2-2-4-运算符">2-2-4、运算符</h4>
<p>加减乘除一应俱全，连逻辑运算符都有!</p>
<p><strong>wenyan vs C++</strong></p>
<pre><code>加一以一。	1+1
除七以三。所餘幾何。	7%3
減六六六六以六六六。名之曰「甲」。	int a=6666-666;
</code></pre>
<h4 id="2-2-5-容器类型">2-2-5 容器类型</h4>
<p>容器类型也支持，而且注意一下，首个下标是从一开始的。</p>
<p><strong>wenyan vs C++</strong></p>
<pre><code>吾有一列。名之曰「数组」。充「数组」以四。以二。	int shuzu[]={4,2};
夫「寶劍」之長。	sword.size;
夫「蒟蒻」之一。	juruo[1];
夫「中国」之「「名」」。	China[&quot;name&quot;]
</code></pre>
<h4 id="2-2-6-进阶语法">2-2-6 进阶语法</h4>
<p>一些 wenyan 的进阶语法。。。。。。</p>
<p><strong>wenyan vs	JavaScript</strong></p>
<pre><code>吾有一術。名之曰「吸星大法」。是術曰。⋯⋯是謂「吸星大法」之術也。	function f(){...}
吾有一術。名之曰「六脈神劍」。欲行是術。必先得六數。曰「甲」。曰「乙」。曰「丙」。曰「丁」。曰「戊」。曰「己」乃行是術曰。⋯⋯是謂「六脈神劍」之術也。	function f(a,b,c,d,e,f){...}
吾有一術。名之曰「翻倍」。欲行是術。必先得一數。曰「甲」。乃行是術曰。乘「甲」以二。名之曰「乙」。乃得「乙」。是謂「翻倍」之術也。	function double(a){var b = a * 2; return b;}
施「翻倍」於「蒟蒻」。	double(juruo);
吾有一數。曰五。書之。	console.log(5);
</code></pre>
<h4 id="2-2-7-循环">2-2-7 循环</h4>
<p>就是那些 for ， while 循环之类的。（注意！ 云云 为 wenyan 语言循环的后面必加的东西！）</p>
<p><strong>wenyan vs C++</strong></p>
<pre><code>為是百遍。⋯⋯ 云云。	for(int i=1;i&lt;=100;i++) ......
恆為是。⋯⋯ 云云。	while(true) ......
乃止。	break
</code></pre>
<p>目前就这些了......</p>
<h3 id="3-编写wenyan语言程序运行">3、编写wenyan语言程序运行</h3>
<p>本人是用洛谷 IDEIDE 进行运行的，当然还有一种网站也可以实现 wenyan 语言的编译运行，还可以实现 wenyan 转 JavaScript 和 Python 的功能！（虽然我都不会......）<br>
这个网站就是：<a href="https://wy-lang.org/ide?example=beer">hhh</a> ！<br>
这里面有不少好康和好玩的东西，你也可以在这里面编译。<br>
而且项目文件还有个脚本src/render.js，它可以把程序渲染成古代书籍的样子。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/ioswoq7n.png" alt="" loading="lazy"></figure>
<h3 id="4-关于wenyan语言编程">4、关于wenyan语言编程</h3>
<p>夫唐、虞之世，結繩而足治，屈指而足算。是時豈料百代之後，計算機械之巧，精於公輸之木鳶，善於武侯之流馬；程式語言之多，繁若《天官》之星宿，奇勝《山經》之走獸。鼠、蟹、鑽、魚，或以速稱。蛇、象、駱、犀，各爭文采。方知鬼之所以夜哭，天之所以雨粟。然以文言編程者 ，似所未有。此非文脈之所以傳，文心之所以保。嗟予小子，遂有斯志。然則數寸之烏絲猶覆於頭，萬卷之素書未破於手；一身長羁于远邦，兩耳久旷于雅言。然夫文章者吾之所宿好，程式者偶承時人之謬譽。故希孟不慚年少，莊生不望無涯。乃作斯言。未能嘔瀝長吉之心血，亦庶幾免於義山之流沫。既成之後，復學干將鑄劍而自飼，越王嚐糞而當先。自謂偶追《十書》之筆意，但恨少八家之淋漓。此子山所謂士衡抚掌而甘心，平子見陋而固宜。然則雖實覆甕之質，尚存斧正之望；雖乏呂相之金，易字之渴蓋同。此亦開源之大義，吾輩之所以勉勵也。一笑。 ----Huang Lingdong（wenyan语言作者）</p>
<p>Huang Lingdong，来自卡耐基梅隆大学，如今大四，明年即将毕业。高中则毕业自上海世界外国语中学。<br>
就是这个小伙子，做出了这个风靡 github 的 wenyan 语言！</p>
<h3 id="5-写在最后">5、写在最后</h3>
<p>到最后，不知道大家看懂没（反正我是看懂了）。<br>
好了，我的 wenyan 语言就讲到这里了，谢谢观看的各位 orz！<br>
tql</p>
<h1 id="提升篇">提升篇</h1>
<h3 id="part-1-输入输出进阶">Part 1 输入输出进阶</h3>
<p>输出和输入是一切语言的基本操作。文言的输出简洁，输入则稍微繁琐。</p>
<h4 id="输出">输出</h4>
<p>输出语句的标志：書之。</p>
<p><code>吾有一數。...書之。</code>：输出数字，阿拉伯形式。</p>
<p>数字的范围是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mo>−</mo><msup><mn>2</mn><mn>256</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>256</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">[-2^{256},2^{256})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">5</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">5</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>其中...中，表示常量使用中文表示，也可使用变量形式。</p>
<p>如：<code>吾有一數。曰三十七。書之。</code>输出 37。</p>
<p><code>吾有一言。...書之。</code>：输出字符串。</p>
<p>字符串表示为<code>「「...」」</code>形式。（注意有二层括号）</p>
<p>如：<code>吾有一言。曰「「字符串」」。書之。</code>输出字符串。</p>
<p>以上每次“书之”语句的输出各占一行。为了在一行内输出多个数字，可以使用以下语句：</p>
<p><code>吾有三數。曰三千二百四十一。曰五百五十。曰一千零五。書之。</code></p>
<p>输出<code>3241 550 1005</code>。</p>
<h4 id="输入">输入</h4>
<p>输入由于还未设专门函数，使用Javascript函数完成。</p>
<p>先看一下A+B Problem给的输入：</p>
<pre><code>施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「數據」。
施「(buf =&gt; buf.toString().trim())」於「數據」。昔之「數據」者。今其是矣。
施「(s =&gt; s.split(' '))」於「數據」。昔之「數據」者。今其是矣。
注曰。「「文言尚菜，無對象之操作，故需 JavaScript 之语法」」。

夫「數據」之一。取一以施「parseInt」。名之曰「甲」。
夫「數據」之二。取一以施「parseInt」。名之曰「乙」。
</code></pre>
<p>其中注曰之前的函数不用管(split除外)。</p>
<p>讲解：<code>「(s =&gt; s.split(' '))」</code>将数据拆分，以某个符号为界限（注意这个符号不在函数结果之内）。</p>
<p><code>「parseInt」</code>将字符串转换为数字。</p>
<p>一些语法会在后提到。</p>
<p>先给一个得到一行数字的函数。</p>
<pre><code>吾有一術。名之曰「输入」。是術曰。
    施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「入」。
    施「(buf =&gt; buf.toString().trim())」於「入」。昔之「入」者。今其是矣。
    施「(s =&gt; s.split('\n'))」於「入」。昔之「入」者。今其是矣。
    乃得「入」也。
是謂「输入」之術也。

吾有一數。曰零。名之曰「其行」。
施「输入」。名之曰「初始输入」。

吾有一術。名之曰「得数」。是術曰。
    吾有一列。名之曰「其数」。
    加「其行」以一。昔之「其行」者。今其是矣。
    夫「初始输入」之「其行」。名之曰「此行」。
    施「(s =&gt; s.split(' '))」於「此行」。昔之「此行」者。今其是矣。
    夫「此行」之長。名之曰「长」。
    吾有一數。曰零。名之曰「下标」。
    為是「长」遍。
        加「下标」以一。昔之「下标」者。今其是矣。
        夫「此行」之「下标」。名之曰「此数」。
        施「parseInt」於「此数」。昔之「此数」者。今其是矣。
        銜「其数」以「此数」。昔之「其数」者。今其是矣。
    云云。
    乃得「其数」也。
是謂「得数」之術也。
</code></pre>
<p>如果看过浅谈，应该不难理解：将初始输入用换行符拆分为各行；使用一个变量表示目前所在的行；每行要用时用空格拆分成各个小字符串；将小字符串转为数字后装入列表返回。</p>
<h3 id="part-2-变量">Part 2 变量</h3>
<h4 id="声明">声明</h4>
<p><code>吾有一數。曰一。名之曰「数」</code>。声明数字。相当于int a=...</p>
<p><code>吾有一言。曰「「字符串」」。名之曰「文」。</code>声明字符串。</p>
<p><code>吾有一爻。曰陽。名之曰「布尔型」。</code>声明布尔型变量。</p>
<p>（布尔值表示：<code>陽</code>为真，<code>陰</code>为假）</p>
<p><code>吾有一元。...名之曰「自动类型」。</code>声明的变量自动判断类型，相当于C++11的<code>auto</code>。</p>
<p>也可以用这个形式：<code>有數一。名之曰「数」。</code></p>
<p>多个变量同时声明：<code>吾有三數。曰一。曰二。曰三。名之曰「数甲」曰「数乙」曰「数丙」。</code></p>
<h4 id="自动变量">自动变量</h4>
<p><code>其</code>：最近的算出的答案。</p>
<p>使用<br>
用括号<code>「」</code>括变量名。如<code>「变量」</code>。</p>
<p>特别地，使用自动变量其时不带括号。</p>
<h4 id="赋值">赋值</h4>
<p><code>...昔之「变量」者。今其是矣。</code>赋前面最近所算出的答案。</p>
<p><code>昔之「变量」者。今...是矣。</code>赋为此语句给出的值。相当于<code>var=...</code></p>
<h3 id="part-3-运算">Part 3 运算</h3>
<h4 id="数字运算">数字运算</h4>
<p><code>加...以...。</code>对应<code>+</code>运算。</p>
<p><code>减...以...。</code>对应<code>-</code>运算。</p>
<p><code>乘...以...。</code>对应<code>*</code>运算。</p>
<p><code>除...以...。</code>对应<code>/</code>运算。注意此运算保留小数。</p>
<p><code>除...以...。</code>所餘幾何。对应<code>%</code>（取模）运算。</p>
<h4 id="大小关系判断">大小关系判断</h4>
<p><code>...大於...</code>对应<code>&gt;</code>运算。</p>
<p><code>...不大於...</code>对应<code>&lt;=</code>运算。</p>
<p><code>...小於...</code>对应<code>&lt;</code>运算。</p>
<p><code>...不小於...</code>对应<code>&gt;=</code>运算。</p>
<p><code>...等於...</code>对应<code>==</code>运算。</p>
<h4 id="布尔值运算">布尔值运算</h4>
<p><code>夫...中有陽乎。</code>对应<code>||</code>（或）运算。</p>
<p><code>夫...中無陰乎。</code>对应<code>&amp;&amp;</code>（与）运算。</p>
<p>如：<code>夫「布尔值甲」「布尔值乙」中有陽乎。</code></p>
<h3 id="part-4-分支与循环">Part 4 分支与循环</h3>
<h4 id="分支语句">分支语句</h4>
<pre><code>若...(条件)者。
    ...(真时代码块)
若非。（等同else，可选）
    ...（假时代码块，可选）
云云。（if结束）
</code></pre>
<p>如：</p>
<pre><code>若三不大於五者。
    吾有一言。曰「「想当然」」。書之。
若非。
    吾有一言。曰「「电脑出锅」」。書之。
云云。
</code></pre>
<p>相当于</p>
<pre><code>if (3&lt;=5) printf(&quot;of course&quot;);
else printf(&quot;bad computer&quot;);
</code></pre>
<p><code>或若...</code>：相当于<code>else if</code>语句。</p>
<p><code>若其然者/若其不然者</code>：当自动变量<code>其</code>不为零/为零时执行语句。</p>
<h4 id="循环语句">循环语句</h4>
<p><code>為是...（循环次数）遍。</code>声明一个执行特定次的循环开始。</p>
<p>相当于<code>for(i=0;i&lt;n;++i)</code></p>
<p><code>恆為是。</code>声明一个死循环的开始。可以用<code>乃止。</code>语句结束。</p>
<p>相当于<code>for(;;)</code></p>
<p><code>云云。</code>声明循环部分结束。（和分支语句一样）</p>
<p><code>乃止。</code>跳出最内的一个循环，相当于<code>break</code>语句。</p>
<p><code>乃止是遍。</code>返回到循环开始，相当于<code>continue</code>语句。</p>
<h3 id="part-5-数组">Part 5 数组</h3>
<h4 id="声明-2">声明</h4>
<p><code>吾有一列。名之曰「数组」。</code></p>
<p>相当于<code>[类型未知] array={};</code></p>
<p>声明带赋值：<code>吾有一列。名之曰「数组」。充「数组」以零。以一。</code></p>
<p>相当于<code>[类型未知] array={0,1};</code></p>
<h4 id="调用">调用</h4>
<p>查询数组内容：<code>夫「数组」之...(下标)</code>返回容器特定下标的值。下标从一开始。如<code>夫「数组」之一，夫「容器」之「「字符串」」。</code></p>
<p>数组内容更改：<code>昔之「数组」之...（下标）者。今...是矣。</code></p>
<p>查询数组大小：<code>夫「数组」之長。</code></p>
<p>相当于<code>list.size()</code></p>
<p>连接不同数组或数组与元素连接：<code>銜「数组」以...(连接目标)。</code>此函数将结果数组返回，不改变原有数组。</p>
<p>声明遍历数组内容的循环开始：<code>凡「数组」中之「变量」。</code>（也是<code>云云。</code>结束）</p>
<p>将数加在数组后面：<code>充「数组」以一。 充「数组」以一。以二。。</code></p>
<p>相当于<code>array.push(1); array.push(1);array.push(2);</code></p>
<h3 id="part-6-函数">Part 6 函数</h3>
<h4 id="声明-3">声明</h4>
<p>函数声明开始：<code>吾有一術。名之曰「函数」。是術曰。</code></p>
<p>相当于<code>[返回值类型未知] function()</code></p>
<p>带参数：</p>
<p><code>吾有一術。名之曰「函数」。欲行是術。必先得一數。曰「参数」。是術曰。</code></p>
<p>相当于<code>[返回值类型未知] function(int var_a)</code></p>
<p><code>吾有一術。名之曰「函数」。欲行是術。必先得...(参数个数)數。曰「参数一」。曰「参数二」。...(声明各种参数)是術曰。</code></p>
<p>注：这里的参数类型也可以是字符串（<code>言</code>）、布尔值等。</p>
<p>函数结束声明：<code>是謂「函数」之術也。</code></p>
<p>格式：</p>
<pre><code>吾有一術。名之曰「函数」。...（参数声明，可选）是術曰。
    ...（函数内容）
是謂「函数」之術也。
</code></pre>
<p>比如这就是一个求线段树右儿子的函数（注意参数不是以指针形式传入的）</p>
<pre><code>吾有一術。名之曰「其右」。欲行是術。必先得一數。曰「节点」。是術曰。
    乘「节点」以二。昔之「节点」者。今其是矣。
    加「节点」以一。昔之「节点」者。今其是矣。
    乃得「节点」也。
是謂「其右」之術也。
</code></pre>
<p>返回结果：<code>乃得...（函数返回值）也。</code>注意编译时它自带右括号，因此在分支或循环语句末尾时要处理（把<code>云云。</code>删去）。</p>
<p>当返回不带返回值时，使用<code>乃歸空無。</code>语句。</p>
<p>调用<br>
函数的调用非常简洁。<code>施「函数」。</code>（无参）<br>
<code>施「函数」於...。於...（代入各参数）</code>（有参）</p>
<p>尽管函数声明时规定了参数个数，但是调用时参数个数可以少于规定个数。这将返回一个函数，表现为原函数前面一些参数固定的版本。</p>
<p>举例：</p>
<pre><code>吾有一術。名之曰「修改」。欲行是術。必先得六數。曰「节点」。曰「左」。曰「右」。曰「改左」。曰「改右」。曰「增值」。是術曰。[1]
    ...
是謂「修改」之術也。

...
施「修改」於一。於一。於「树长」。名之曰「简易修改」。[2]
...
施「简易修改」於「改左」。於「改右」。於「增值」。...[3]
</code></pre>
<p>说明：上面代码中[1]处声明了线段树的修改函数，其中有六个参数。考虑到主函数中调用此函数前三个参数是固定的，于是在[2]处通过不完全参数定义了新函数<code>「简易修改」</code>，调用简易版函数时（[3]）只用带入原函数的后三个参数就可以了。</p>
<p>附加：<a href="https://github.com/wenyan-lang/wenyan/blob/master/documentation/Nested-Function-Calls.md">函数嵌套的一种简易方法</a></p>
<h3 id="part-7-结构体">Part 7 结构体</h3>
<p>声明：<code>吾有一物。名之曰「结构体」。</code></p>
<p>带内容声明：</p>
<pre><code>吾有一物。名之曰「结构体」。其物如是。
    物之「「数」」者。數曰一。
    物之「「文」」者。言曰「「字符串」」。
    ...（声明结构体各个内容）
是謂「结构体」之物也。
</code></pre>
<p>用法与数组类似。</p>
<h3 id="part-8-标准库">Part 8 标准库</h3>
<p>调用标准库前声明：<code>吾嘗觀「「...（库名）」」之書。方悟「...（调用函数名）」之義。</code>声明后可以像正常函数一样调用。</p>
<p>也可以一次声明多个：<code>吾嘗觀「「算經」」之書。方悟「正弦」「餘弦」之義。</code></p>
<p>调用特定文件的语法举例：<code>吾嘗觀「「codes」」中「「luogu」」中「「p1001」」之書。</code>调用codes/luogu/p1001。</p>
<p><a href="https://github.com/wenyan-lang/wenyan/blob/master/documentation/Standard-Lib.md">标准库所有函数</a></p>
<p><a href="https://github.com/wenyan-lang/wenyan/blob/master/documentation/Importing.md">官方说明·导入</a></p>
<p><code>算經</code>库<br>
算经库提供了一些数学函数。</p>
<p>部分标准库函数：</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/h8mq58pi.png" alt="" loading="lazy"></figure>
<p><code>列經</code>库<br>
提供了数组操作。这里只提供部分常用操作。</p>
<p>函数	对应</p>
<p><code>遍施</code>	对数组内所有数<code>x</code>执行    <code>x=function(x)</code>后返回<br>
<code>排序</code>	<code>sort()</code><br>
<code>倒序</code>	<code>reverse()</code><br>
<code>曆法</code>库<br>
历法库提供时间操作。</p>
<p><code>今何紀元時 言今之日時 今年何年 今年何年號 今年何干支 今時何時 今時何小時 今刻何刻 今分何分 今秒何秒</code> 等函数。很大一部分都是古人算法，现在不常用</p>
<p>调用<code>言今之日時</code>函数可以直接输出现在的时间。</p>
<p>Part 9 注释</p>
<pre><code>注曰。「「注释内容」」。

批曰。「「注释内容」」。

疏曰。「「注释内容」」。
</code></pre>
<p>它们相当于其他语言中被<code>/*</code>,<code>*/</code>括起的注释。</p>
<h3 id="part-10-杂项">Part 10 杂项</h3>
<p>连接两个字符串：<code>加「字符串甲」以「字符串乙」。</code>相当于<code>strcat(str_a,str_b);</code></p>
<p>宏定义： <code>或云「「宏名称」」。 蓋謂「「替换内容」」。</code></p>
<p><a href="https://github.com/wenyan-lang/wenyan/blob/master/documentation/Macros.md">官方说明</a></p>
<p>比如：<code>或云「「書「甲」焉」」。 蓋謂「「吾有一言。曰「甲」。書之」」。</code></p>
<p>相当于<code>#define output(str) cout&lt;&lt;str</code></p>
<p>异常处理（<code>try-catch</code>语句）</p>
<p><a href="https://github.com/wenyan-lang/wenyan/blob/master/documentation/Try-Catch.md">官方说明</a></p>
<p><a href="https://ide.wy-lang.org/?example=try">示例</a></p>
<p><code>try</code>语句：<code>姑妄行此。</code>表示需检测异常语句段开始。</p>
<p><code>throw</code>语句：<code>嗚呼。「「异常内容」」之禍。</code>表示检测到异常，跳到<code>catch</code>段处理。相当于<code>throw &quot;error&quot;;</code></p>
<p><code>catch</code>语句：如事不諧。表示检测到异常后执行的代码块开始。</p>
<p>在<code>catch</code>语句内判断异常内容的特殊<code>if</code>语句：<code>豈「「异常内容」」之禍歟。</code></p>
<p>上述特殊<code>if</code>语句对应的<code>else</code>：<code>不知何禍歟。</code></p>
<p>上述<code>else</code>获得具体异常信息：<code>不知何禍歟。名之曰「异常信息」。</code></p>
<p><code>catch</code>语句结束：<code>乃作罷。</code></p>
<p>通俗点，就是先执行<code>try</code>到<code>catch</code>之间的代码，这一段代码中若满足一些条件使得其中的<code>throw</code>语句被执行了，那么忽略之后所有<code>try</code>到<code>catch</code>间的代码，执行<code>catch</code>段代码。如果没有，则<code>catch</code>段代码不被执行。</p>
<h4 id="文言官方文件附带">文言官方文件附带</h4>
<p><a href="http://wenyan-lang.lingdong.works/ide.html">官方IDE</a></p>
<p>把代码渲染成古文样式（浅谈已说）</p>
<p>将输出的数转为汉字的功能</p>
<p>一些样例文件（官方IDE中可以找到）</p>
<h3 id="part-11-例子">Part 11 例子</h3>
<h4 id="ab">A+B</h4>
<pre><code>施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「數據」。
施「(buf =&gt; buf.toString().trim())」於「數據」。昔之「數據」者。今其是矣。
施「(s =&gt; s.split(' '))」於「數據」。昔之「數據」者。今其是矣。

夫「數據」之一。取一以施「parseInt」。名之曰「甲」。
夫「數據」之二。取一以施「parseInt」。名之曰「乙」。

加「甲」以「乙」。書之。
</code></pre>
<h4 id="输入模板">输入模板</h4>
<pre><code>吾有一術。名之曰「函数」。欲行是術。必先得二數。曰「甲」。曰「乙」。是術曰。
	吾有一列。名之曰「列」。
   	為是「甲」遍。
   		銜「列」以「乙」。昔之「列」者。今其是矣。
   	云云。
    吾有一言。曰「「黄河流水鸣溅溅」」。書之。
    夫「列」之長。書之。
    乃得「乙」也。
是謂「函数」之術也。

施「函数」於四。於六。書之。
</code></pre>
<h4 id="大常数线段树">大常数线段树</h4>
<pre><code>吾嘗觀「「算經」」之書。方悟「取底」之義。

吾有一術。名之曰「输入」。是術曰。
    施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「入」。
    施「(buf =&gt; buf.toString().trim())」於「入」。昔之「入」者。今其是矣。
    施「(s =&gt; s.split('\n'))」於「入」。昔之「入」者。今其是矣。
    乃得「入」也。
是謂「输入」之術也。

吾有一數。曰零。名之曰「其行」。
施「输入」。名之曰「初始输入」。

吾有一術。名之曰「得数」。是術曰。
    吾有一列。名之曰「其数」。
    加「其行」以一。昔之「其行」者。今其是矣。
    夫「初始输入」之「其行」。名之曰「此行」。
    施「(s =&gt; s.split(' '))」於「此行」。昔之「此行」者。今其是矣。
    夫「此行」之長。名之曰「长」。
    吾有一數。曰零。名之曰「下标」。
    為是「长」遍。
        加「下标」以一。昔之「下标」者。今其是矣。
        夫「此行」之「下标」。名之曰「此数」。
        施「parseInt」於「此数」。昔之「此数」者。今其是矣。
        充「其数」以「此数」。
    云云。
    乃得「其数」也。
是謂「得数」之術也。

吾有一列。名之曰「权」。
吾有一列。名之曰「懒标记」。
吾有一列。名之曰「原值」。

吾有一術。名之曰「其左」。欲行是術。必先得一數。曰「节点」。是術曰。
    乘「节点」以二。昔之「节点」者。今其是矣。
    乃得「节点」也。
是謂「其左」之術也。

吾有一術。名之曰「其右」。欲行是術。必先得一數。曰「节点」。是術曰。
    乘「节点」以二。昔之「节点」者。今其是矣。
    加「节点」以一。昔之「节点」者。今其是矣。
    乃得「节点」也。
是謂「其右」之術也。

吾有一術。名之曰「上传」。欲行是術。必先得一數。曰「节点」。是術曰。
    施「其左」於「节点」。名之曰「左子」。
    施「其右」於「节点」。名之曰「右子」。
    夫「权」之「左子」。名之曰「左权」。
    夫「权」之「右子」。名之曰「右权」。
    加「左权」以「右权」。昔之「权」之「节点」者。今其是矣。
是謂「上传」之術也。

吾有一術。名之曰「打标记」。欲行是術。必先得四數。曰「节点」。曰「左」。曰「右」。曰「标记」。是術曰。
    夫「懒标记」之「节点」。名之曰「原标」。
    加「原标」以「标记」。昔之「懒标记」之「节点」者。今其是矣。
    減「右」以「左」。名之曰「长」。
    加「长」以一。昔之「长」者。今其是矣。
    乘「长」以「标记」。名之曰「增值」。
    夫「权」之「节点」。名之曰「原权」。
    加「原权」以「增值」。昔之「权」之「节点」者。今其是矣。
是謂「打标记」之術也。

吾有一術。名之曰「其中」。欲行是術。必先得二數。曰「左」。曰「右」。是術曰。
    加「左」以「右」。名之曰「结果」。
    除「结果」以二。昔之「结果」者。今其是矣。
    施「取底」於「结果」。昔之「结果」者。今其是矣。
    乃得「结果」也。
是謂「其中」之術也。

吾有一術。名之曰「下传」。欲行是術。必先得三數。曰「节点」。曰「左」。曰「右」。是術曰。
    夫「懒标记」之「节点」。名之曰「其标」。
    若「其标」不等於零者。
        若「左」小於「右」者。
            施「其中」於「左」。於「右」。名之曰「中」。
            加「中」以一。名之曰「右始」。
            施「其左」於「节点」。名之曰「左子」。
            施「其右」於「节点」。名之曰「右子」。
            施「打标记」於「左子」。於「左」。於「中」。於「其标」。
            施「打标记」於「右子」。於「右始」。於「右」。於「其标」。
        云云。
        昔之「懒标记」之「节点」者。今零是矣。
    云云。
是謂「下传」之術也。

吾有一術。名之曰「建树」。欲行是術。必先得三數。曰「节点」。曰「左」。曰「右」。是術曰。
    若「左」等於「右」者。
        夫「原值」之「左」。昔之「权」之「节点」者。今其是矣。
    若非。
        施「其中」於「左」。於「右」。名之曰「中」。
        加「中」以一。名之曰「右始」。
        施「其左」於「节点」。名之曰「左子」。
        施「其右」於「节点」。名之曰「右子」。
        施「建树」於「左子」。於「左」。於「中」。
        施「建树」於「右子」。於「右始」。於「右」。
        施「上传」於「节点」。
    云云。
是謂「建树」之術也。

吾有一術。名之曰「包含」。欲行是術。必先得四數。曰「左」。曰「右」。曰「改左」。曰「改右」。是術曰。
    若「左」小於「改左」者。乃得陰也。
    若「右」大於「改右」者。乃得陰也。
    乃得陽也。
是謂「包含」之術也。

吾有一術。名之曰「修改」。欲行是術。必先得六數。曰「节点」。曰「左」。曰「右」。曰「改左」。曰「改右」。曰「增值」。是術曰。
    施「下传」於「节点」。於「左」。於「右」。
    施「包含」於「左」。於「右」。於「改左」。於「改右」。名之曰「是否包含」。
    若「是否包含」等於陽者。
        施「打标记」於「节点」。於「左」。於「右」。於「增值」。
    云云。
    若「是否包含」等於陰者。
        施「其中」於「左」。於「右」。名之曰「中」。
        加「中」以一。名之曰「右始」。
        施「其左」於「节点」。名之曰「左子」。
        施「其右」於「节点」。名之曰「右子」。
        若「改左」不大於「中」者。
            施「修改」於「左子」。於「左」。於「中」。於「改左」。於「改右」。於「增值」。
        云云。
        若「改右」大於「中」者。
            施「修改」於「右子」。於「右始」。於「右」。於「改左」。於「改右」。於「增值」。
        云云。
        施「上传」於「节点」。
    云云。
是謂「修改」之術也。

吾有一術。名之曰「查询」。欲行是術。必先得五數。曰「节点」。曰「左」。曰「右」。曰「改左」。曰「改右」。是術曰。
    施「下传」於「节点」。於「左」。於「右」。
    施「包含」於「左」。於「右」。於「改左」。於「改右」。名之曰「是否包含」。
    吾有一數。曰零。名之曰「果」。
    若「是否包含」等於陽者。
        夫「权」之「节点」。昔之「果」者。今其是矣。
    云云。
    若「是否包含」等於陰者。
        施「其中」於「左」。於「右」。名之曰「中」。
        加「中」以一。名之曰「右始」。
        施「其左」於「节点」。名之曰「左子」。
        施「其右」於「节点」。名之曰「右子」。
        若「改左」不大於「中」者。
            施「查询」於「左子」。於「左」。於「中」。於「改左」。於「改右」。名之曰「左权」。
            加「果」以「左权」。昔之「果」者。今其是矣。
        云云。
        若「改右」大於「中」者。
            施「查询」於「右子」。於「右始」。於「右」。於「改左」。於「改右」。名之曰「右权」。
            加「果」以「右权」。昔之「果」者。今其是矣。
        云云。
    云云。
    乃得「果」也。
是謂「查询」之術也。

施「得数」。名之曰「其数」。
夫「其数」之一。名之曰「数量」。
夫「其数」之二。名之曰「操作数」。
乘「数量」以四。名之曰「树长」。
為是「树长」遍。
    充「权」以零。
    充「懒标记」以零。
云云。
施「得数」。昔之「其数」者。今其是矣。
吾有一數。曰零。名之曰「下标」。
為是「数量」遍。
    加「下标」以一。昔之「下标」者。今其是矣。
    夫「其数」之「下标」。名之曰「此数」。
    充「原值」以「此数」。
云云。
施「建树」於一。於一。於「数量」。
為是「操作数」遍。
    施「得数」。昔之「其数」者。今其是矣。
    夫「其数」之一。名之曰「操作」。
    夫「其数」之二。名之曰「改左」。
    夫「其数」之三。名之曰「改右」。
    若「操作」等於一者。
        夫「其数」之四。名之曰「增值」。
        施「修改」於一。於一。於「数量」。於「改左」。於「改右」。於「增值」。
    云云。
    若「操作」等於二者。
        施「查询」於一。於一。於「数量」。於「改左」。於「改右」。名之曰「果」。
        加「果」以零。昔之「果」者。今其是矣。
        吾有一數。曰「果」。書之。
    云云。
云云。
</code></pre>
<h4 id="函数-数组综合">函数、数组综合</h4>
<pre><code>吾有一術。名之曰「函数」。欲行是術。必先得二數。曰「甲」。曰「乙」。是術曰。
	吾有一列。名之曰「列」。
   	為是「甲」遍。
   		銜「列」以「乙」。昔之「列」者。今其是矣。
   	云云。
    吾有一言。曰「「黄河流水鸣溅溅」」。書之。
    夫「列」之長。書之。
    乃得「乙」也。
是謂「函数」之術也。

施「函数」於四。於六。書之。
</code></pre>
<h4 id="洛谷p5834-moobuzz">洛谷P5834 MooBuzz</h4>
<pre><code>注曰。「「注曰语句是程序中的注释。」」。
注曰。「「注释中说明的语句是简体字。实际编程中需要使用繁体。」」。

吾嘗觀「「算經」」之書。方悟「取底」之義。
注曰。「「吾尝观...之义语句导入库中函数。」」。

吾有一術。名之曰「判断合法」。欲行是術。必先得一數。曰「甲」。是術曰。
注曰。「「判断是否会被报出。吾有一术名之曰语句声明函数」」。
注曰。「「欲行其术必先得...曰语句声明参数。无参时可省略。曰可以有多个。」」。
注曰。「「是术曰语句声明函数开始」」。
    除「甲」以三。所餘幾何。名之曰「除三之余」。
    若「除三之余」等於零者。乃得陰也。
    注曰。「「若...乃语句表示满足某个条件时的返回值。」」。
    注曰。「「三的倍数不会被报出」」。
    除「甲」以五。所餘幾何。名之曰「除五之余」。
    若「除五之余」等於零者。乃得陰也。
    注曰。「「五的倍数不会被报出」」。
    乃得陽也。
    注曰。「「如果不是三的倍数也不是五的倍数，它就会被报出」」。
    注曰。「「返回布尔值。阳表示真，阴表示假。」」。
是謂「判断合法」之術也。
注曰。「「是谓...之术也语句声明函数结束。」」。

施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「初始输入」。
施「(buf =&gt; buf.toString().trim())」於「初始输入」。昔之「初始输入」者。今其是矣。
施「parseInt」於「初始输入」。名之曰「甲」。
注曰。「「输入部分。使用Javascript的语法。」」。
注曰。「「parseInt函数将字符串转换为数字」」。
除「甲」以八。名之曰「周期数」。
注曰。「「计算此数之前的完整周期次数。」」。
注曰。「「加/乘/除...以语句进行运算。」」。
注曰。「「名之曰语句声明变量。其值在前面语句提到。」」。
施「取底」於「周期数」。昔之「周期数」者。今其是矣。
注曰。「「此语言除法不会向下取整，需要使用函数。」」。
注曰。「「施...于语句执行函数。于传入参数，可以有多个。」」。
注曰。「「昔之..者斤其是矣语句将变量重新复值。其值在前面语句提到。」」。
乘「周期数」以十五。名之曰「结果」。
加「结果」以负一。昔之「结果」者。今其是矣。
注曰。「「现在的结果是上文中15k-1的值。」」。
除「甲」以八。所餘幾何。名之曰「剩余」。
注曰。「「往后剩余要找的数字数量即为N除8的余数。」」。
注曰。「「除...以...所余几何语句计算余数。」」。
恆為是。
注曰。「「恒为是语句表明一个死循环。」」。
    若「剩余」小於一者。乃止。云云。
    注曰。「「现在已经是目标，退出循环并输出它」」。
    注曰。「「乃止语句表明退出循环，相当于break。」」。
    注曰。「「若...云云语句表明若满足条件会执行的语句。相当于if。」」。
    加「结果」以一。昔之「结果」者。今其是矣。
    施「判断合法」於「结果」。名之曰「是否合法」。
    注曰。「「将当前数增加一，然后检查是否会被报出」」。
    若「是否合法」等於陽者。
        加「剩余」以负一。昔之「剩余」者。今其是矣。
        注曰。「「次数会被报出。找的数的剩余数量减一。」」。
    云云。
云云。
注曰。「「此处的云云语句说明循环结束。」」。
加「结果」以零。書之。
注曰。「「将最终的结果输出。」」。
注曰。「「书之语句进行输出。调用此语句将在最后额外输出一个换行符。」」。
</code></pre>
<p>c++\</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;
typedef long long ll;

bool check(ll x) {
    if (x%3==0) return false;
    if (x%5==0) return false;
    return true;
}
int main() {
    ll k; scanf(&quot;%lld&quot;,&amp;k);
    ll res=15LL*(k/8)-1; k&amp;=7;
    while (k) {
        if (check(++res)) --k;
    }
    printf(&quot;%d&quot;, res);
    return 0;
}
</code></pre>
<h2 id="总结">总结</h2>
<p>文言是一种广受欢迎的新生编程语言，优缺点总结如下：</p>
<h3 id="优点">优点</h3>
<p>对于中国人来说，代码可以作为注释，容易理解程序作用</p>
<p>弘扬中华传统文化</p>
<h3 id="缺点">缺点</h3>
<p>不方便输入，如一些繁体字、特殊括号等</p>
<p>一些函数如输入还未完善</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[csp5020]]></title>
        <id>https://wyyszl.github.io/post/csp5020/</id>
        <link href="https://wyyszl.github.io/post/csp5020/">
        </link>
        <updated>2021-01-16T12:14:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="赛前琐事">赛前琐事：</h1>
<h3 id="day-28">day -28：</h3>
<p>whk 考试，全线炸掉，扎到 200 名。</p>
<h3 id="day-26">day -26：</h3>
<p>csp 初赛，上午考的一脸蒙，下午还好。最后 tg 60多，pj 85.5(非常怀疑去年某培改了分数，因为我去年pj也是 85.5，而那时我还不知道什么是字符串。。。)</p>
<p>zjx 大佬 tg 94，SX 第一，还提前了 半个多小时交卷，这人才初二，这是人干的事？</p>
<h3 id="day-24">day -24：</h3>
<p>zjx 大佬开始集训，连续 20 个下午不上课，然后我们班的管理电脑的人就成我了。</p>
<p>巧合的是，这天 whk 老师因我 whk 考试炸掉而找我谈话，其中一句“发展自己的兴趣前一定要把根本抓好。”似乎是在“建议”我停学 OI，还说我是“25 名的水平考虑 200 名”，让我在期中考“发挥好自己的水平”，我谔谔。</p>
<h3 id="day-22">day -22：</h3>
<p>得知期中考撞上了 csp（其实这句话有误，毕竟期中考在 csp 后2天），郁闷。</p>
<p>经过“慎重”考虑后，我决定全力冲 OI。</p>
<h3 id="day-14">day -14：</h3>
<p>教练定下有过 pj 省一 pj 260 ，无 pj 省一的 pj 省一的要求，pj 260 对于一些大佬或强生的人来说很容易，但对于我确实很难，<s>当时我就想，要知道这我去年 t2 就不写 freopen 了</s></p>
<p>(再次说明：坐标 SX(是 shanxi,!= shaanxi))</p>
<h3 id="day-10">day -10:</h3>
<p>初二体测退后一周至 11.7（== csp），ty 老师要求无论是否补测都要到位，我与老师说 OI 的事，结果。。。</p>
<p><s>还是人太少，</s> 信息（！=OI）老师说有近 40 人会耽误，然后就好了。。。</p>
<h3 id="day-1试机">day -1：试机</h3>
<p>一进考场：<br>
笔……笔记本！？</p>
<p>抬头一看:山西智/创城认证点(((</p>
<p><s>忽然想起 zjx 的“笔记本省选”好像就是在这里。</s></p>
<p>不过性能还好，只是这“ctrl”键。。。</p>
<p>试机时我打了一份位运算 a+b，挂了，后来试了试 hello world，也炸了。</p>
<p>忽然发现这电脑不能同时用 freopen 和 cin 优化。。。</p>
<p>大佬 xty 打了一个输出一堆人 AK 自己爆零的程序，真 fAKe。。。</p>
<p>晚上看到兰州布病爆发的消息，下意识感觉完了。</p>
<p>但看到只有兰州有，而且只有央视新闻发了这个消息，又感觉好了很多。</p>
<p>考前的晚上我一直睡不着，毕竟我太想赢了。</p>
<p><s>当然也可能是睡太早了</s></p>
<h1 id="考时">考时</h1>
<h3 id="day-1-上午pj">day 1 上午，pj：</h3>
<p>一来了考点，就莫名其妙地收到了教练给我们的巧克力</p>
<p>我忽想起小学时的一位演说 <s>传销</s> 家老师说的话</p>
<p>看来考前吃巧克力似乎有一些道理。。。</p>
<p>开考：</p>
<p>先看 t1：</p>
<p>优秀的拆分？这玩意不是道黑体吗？害怕.jpg.png.psd.asdf</p>
<p>看了看题发现不是，但也没什么思路，忽看到<code>可以证明，在规定了拆分数字的顺序后，该拆分方案是唯一的</code>,立刻清醒：</p>
<p>这不就是二进制转换吗？</p>
<p>10 min A了它。</p>
<p>再看 t2：</p>
<p>看了看题发现很简单，吸取上次的教训，我看了看数据范围，然后懵了。</p>
<p><s>十 万 人 同 台 竞 技 N O I，获 奖 概 率 高 达 60% ， 预 计 六 万 人 拿 牌。</s></p>
<p><s>蒟蒻弱弱地问一句：这么多名额，给 SX 多少？</s></p>
<p>开始乱想，sort、插排、二分、倒搜、桶排。</p>
<p>后来想到了堆，发现可以开两个堆（当时脑子糊得厉害，根本没意识到这就是对顶堆）。</p>
<p>30 min，过了大样例。</p>
<p>t3:</p>
<p>想了 30 min ，没思路，20min栈30pts看下一道题。</p>
<p>t4：</p>
<p>我一看这不就是个图论吗？然后使劲想，没想出来。然后神经地用伪证证明它有后效性不能 动态规划。</p>
<p>想了 1h 没思路，20pts深度优先搜索滚回 t3。</p>
<p>然后 t3 还是没思路，不想交卷，坐等15min。</p>
<p>一出去就听见有人说 t4 正解是 动态规划。</p>
<p>我。。。。。</p>
<p>估分：100+100+30+20=250 pts&lt;260pts</p>
<p>暴毙了。。。。。</p>
<p>人陆陆续续地出来，xty 大佬估分 300 ，还有初三大佬估分 365，初一有人估分 300。我。。。。。</p>
<p>难怪有人说 OI 是单调队列，oi 考试是维护单调队列。。。</p>
<p>临走时拍照，大佬们调侃说是&quot;最后的照片&quot;，但这对于我，那时以为似乎并非调侃。</p>
<h2 id="day-1-下午tg">day 1 下午，tg：</h2>
<p>教练说减低难度，如果我们tg拿到260pts也行。</p>
<p><s>这叫降低</s>？</p>
<p>然鹅其实是160pts。。。</p>
<p><s>密码外面还有括号是什么玄学操作</s></p>
<p>t1：</p>
<p><s>看看人家 geergaoli 自动去掉0，再看看洛谷和我们学校的 oj 明天是 csp 结果距离 csp 0天</s></p>
<p><s>zjx:那是向下取整</s></p>
<p><s>我。。。</s></p>
<p>看一眼题：这和 2016 pj-t2 不一样吗？就这？</p>
<p>看一眼数据范围：。。。</p>
<p>想也不想，先暴力，25 min ，过了前两个样例。</p>
<p>然后想到了一种类似跳表的东西，就是一年一年跳，然后一月一月，一天一天，到1582年10月特殊处理。10min写出，调了 15min过了两个样例。</p>
<p>复杂度依然高，我想到可以分段算，[1600,无穷) 二分 ，其余暴力。</p>
<p>然后代码超 200 行，感觉不对，<s>又感觉这么长时间都在写 t1有点给学校丢脸</s>，便去 t2。</p>
<p>t2：</p>
<p>暴力，40pts，10min。</p>
<p>t3：</p>
<p>看了看题，想到了线段树，码了一棵，结果样例都过不了。</p>
<p>然后玩命条，<s>始终没想到回去重新看看题，看错题了嘤嘤嘤。</s></p>
<p>调不出来，造了造数据，都过了，以为数据错了，<s>根本没想到是看错题了</s>，就去 t4。。。</p>
<p>t4：</p>
<p>看一眼题，就发现这是一道博弈论。然鹅我根本不会博弈论。。。</p>
<p>20 pts瞎搞。滚回 t1。</p>
<p>t1：</p>
<p>看了10min，还是没思路。<s>忽想起了“瞎搞出奇迹，偏分最神奇”的“忠告”</s>，瞎搞发现有 80pts，20min去t2。</p>
<p>t2：</p>
<p>忽然反应过来，10min100pts后瞎搞t3t4。</p>
<p>估分：[70,80]+100+[0,10]+[0,20]=[170,210]</p>
<p>出来后发现t4初三高一高二的学长也都不会做，t1会做做不出来，<s>然后一起吐槽t1</s>。</p>
<p>过了一会，zjx 出来了，大家围过去问他t1t4做出来了吗？</p>
<p>然后他居然说做出来了，还说估分 100+100+40+100=340！！！</p>
<p>这是人干的事？</p>
<p>他是不是人无所谓，我当时感觉很好，<strong>以为</strong>不会暴毙了。</p>
<h1 id="赛后">赛后</h1>
<h3 id="1day上午">1day上午：</h3>
<p>没什么事，写了写whk作业。</p>
<h3 id="下午">下午</h3>
<p>2点：我要到了 SX tg的代码，然后决定写完作业自测。</p>
<p>4点：自测。</p>
<p>我先拿出我最有把握的t2，然后兴致勃勃地放到落谷上测，以为会一片 AC，结果是黑绿几乎持平。</p>
<p>心态立刻崩掉。</p>
<p>没信心去测t1t3t4，然而我还是去测了，毕竟还是有侥幸心理。</p>
<p>t1黑绿持平，t3t4全wa或Tle。</p>
<p>这样一来，估分 70+60+0+0=130pts&lt;160pts</p>
<p>无语。。。。。</p>
<h3 id="whk-考试">whk 考试</h3>
<p>希望不要炸掉，希望不要 die of whk。。。</p>
<p>然而炸了。。。</p>
<h3 id="n-days-later">n days later</h3>
<p>最终成绩出来了，</p>
<p>pj=100+100+30+20</p>
<p>tg=70+60+0+20</p>
<p>有人说tgt3线段树能拿 70。</p>
<p>草率了，白白丢了70分。</p>
<p>tgt3的70分啊。/kk</p>
<p>tgt2我开了 ull 了，然而。。。</p>
<p>结果高中生都考的不好，就这成绩还拿了1=和蓝钩。。。</p>
<h3 id="调侃">调侃</h3>
<p>NOIP 5018 后，大家知道卡 int 要用 longlong</p>
<p>csp 5019后，大家知道卡 longlong 要用 ull。</p>
<p>csp 5020后，大家知道卡 ull要特判。</p>
<p>我估计，不出两年，OI一定考高精度，不出5年，一定考 fft。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[差分]]></title>
        <id>https://wyyszl.github.io/post/chai-fen/</id>
        <link href="https://wyyszl.github.io/post/chai-fen/">
        </link>
        <updated>2020-10-20T14:44:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-基础差分">一、基础差分</h2>
<p>1.问题：多次区间修改，一次单点查询<br>
2.思路：对于区间问题，我们可以使用前缀和与线段树。线段树过于复杂，我们可以从前缀和来思考。考虑到每一次单点修改，前缀和都是又该点开始到结尾的区间修改，我们可以将原数组当做某一数组的前缀和，然后对该数组进行两次单点修改，最后再求前缀和即可。<br>
3.由原数组推差分数组：差分是前缀和的逆运算，因而我们应该先知道前缀和公式，易得为：<code>fsum[i]=fsum[i-1]+a[i];</code>，对该等式进行变形，得差分公式：<code>a[i]=fsum[i]-fsum[i-1];</code>，而对于该公式，<code>fsum</code>-&gt;a,<code>cf</code>-&gt;差分数组.<br>
4.结果：求前缀和即为原数组更改后<br>
5.时间复杂度：<code>O(m+n)</code></p>
<h2 id="二-二维差分1">二、二维差分1</h2>
<p>1.思路：将二维拆分为一维<br>
2.时间复杂度:<code>O(mn)</code></p>
<h2 id="二-二维差分2">二、二维差分2</h2>
<p>1.思路：同一维<br>
2.复习二维前缀和：<img src="https://cdn.luogu.com.cn/upload/image_hosting/moezmwuh.png" alt="" loading="lazy"><br>
黄色部分的和即为 fsum[3][3]<br>
公式：<code>fsum[i][j]=fsum[i-1][j]+fsum[i][j-1]-fsum[i-1][j-1]+a[i][j];</code><br>
3.差分公式：<code>cf[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1];</code><br>
4.更改思路：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/jf0wl7ar.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[点名器]]></title>
        <id>https://wyyszl.github.io/post/dian-ming-qi/</id>
        <link href="https://wyyszl.github.io/post/dian-ming-qi/">
        </link>
        <updated>2020-10-18T14:53:33.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="代码">代码</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,k;
string s[64];
string t[15];
string asdf;
int  f[64];
int l=0;
int m;
int main() {
	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
	int*a;
	a=new int [n+1]();
	for(int i=1; i&lt;=m; ++i) {
		cin&gt;&gt;t[i];
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;s[i];
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;a[i];
		a[i] =a[i] bitor 0;
	}
	cin&gt;&gt;asdf;
	for(int i=1; i&lt;=m; ++i) {
		for(int j=1; j&lt;=n; ++j) {
			if(s[j]==t[i]) {
				a[j]=0x3f3f3f3f;
				break;
			}
		}
	}
	srand(time(0));
	for(int i=1; i&lt;=n; ++i) {
		if(a[i]&lt;k){
			f[++l]=i;
		}
	}
	if(not(l))
	cout&lt;&lt;&quot;无结果&quot;;
asdf:
	int tt=rand()%(l+1)+1;
	cout&lt;&lt;s[f[tt]];
	++a[f[tt]];
	freopen(&quot;1.in&quot;,&quot;w&quot;,stdout);
	cout&lt;&lt;n&lt;&lt;' '&lt;&lt;m&lt;&lt;' '&lt;&lt;k&lt;&lt;endl;
	for(int i=1; i&lt;=m; ++i) {
		cout&lt;&lt;t[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	for(int i=1; i&lt;=n; ++i) {
		cout&lt;&lt;s[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	for(int i=1; i&lt;=n; ++i) {
		cout&lt;&lt;a[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl&lt;&lt;s[tt]&lt;&lt;endl;
	for(int i=1; i&lt;=10; ++i)i=sqrt(i);

	return  0;
}
</code></pre>
<h3 id="代码解释">代码解释：</h3>
<p>无<br>
<s>不要问我第 22 行的用处</s></p>
<h3 id="使用方法">使用方法</h3>
<ul>
<li><s>0.编译</s></li>
<li>1.创建一个文本文档名为 1.in</li>
<li>2.在 1.in 中输入以下格式内容：</li>
</ul>
<pre><code>第一行：n(总人数)，m(无需点到的人数)，k(最多次数)
第二行：无需点到的人（用空格隔开）
第三行:名称（用空格隔开）
第四行：n 个 0（用空格隔开）
第五行：任意一个无需点到的名称

</code></pre>
<ul>
<li>3 运行</li>
<li>4 当出现 “无结果时”，至第二部。</li>
</ul>
<h3 id="你可能需要">你可能需要</h3>
<p>链接: https://pan.baidu.com/s/1yK09mb6LmGqgOP4dT4QZEA<br>
提取码: xes9</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="代码">代码</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,k;
string s[64];
string t[15];
string asdf;
int  f[64];
int l=0;
int m;
int main() {
	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
	int*a;
	a=new int [n+1]();
	for(int i=1; i&lt;=m; ++i) {
		cin&gt;&gt;t[i];
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;s[i];
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;a[i];
		a[i] =a[i] bitor 0;
	}
	cin&gt;&gt;asdf;
	for(int i=1; i&lt;=m; ++i) {
		for(int j=1; j&lt;=n; ++j) {
			if(s[j]==t[i]) {
				a[j]=0x3f3f3f3f;
				break;
			}
		}
	}
	srand(time(0));
	for(int i=1; i&lt;=n; ++i) {
		if(a[i]&lt;k){
			f[++l]=i;
		}
	}
	if(not(l))
	cout&lt;&lt;&quot;无结果&quot;;
asdf:
	int tt=rand()%(l+1)+1;
	cout&lt;&lt;s[f[tt]];
	++a[f[tt]];
	freopen(&quot;1.in&quot;,&quot;w&quot;,stdout);
	cout&lt;&lt;n&lt;&lt;' '&lt;&lt;m&lt;&lt;' '&lt;&lt;k&lt;&lt;endl;
	for(int i=1; i&lt;=m; ++i) {
		cout&lt;&lt;t[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	for(int i=1; i&lt;=n; ++i) {
		cout&lt;&lt;s[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	for(int i=1; i&lt;=n; ++i) {
		cout&lt;&lt;a[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl&lt;&lt;s[tt]&lt;&lt;endl;
	for(int i=1; i&lt;=10; ++i)i=sqrt(i);

	return  0;
}
</code></pre>
<h3 id="代码解释">代码解释：</h3>
<p>无<br>
<s>不要问我第 22 行的用处</s></p>
<h3 id="使用方法">使用方法</h3>
<ul>
<li><s>0.编译</s></li>
<li>1.创建一个文本文档名为 1.in</li>
<li>2.在 1.in 中输入以下格式内容：</li>
</ul>
<pre><code>第一行：n(总人数)，m(无需点到的人数)，k(最多次数)
第二行：无需点到的人（用空格隔开）
第三行:名称（用空格隔开）
第四行：n 个 0（用空格隔开）
第五行：任意一个无需点到的名称

</code></pre>
<ul>
<li>3 运行</li>
<li>4 当出现 “无结果时”，至第二部。</li>
</ul>
<h3 id="你可能需要">你可能需要</h3>
<p>链接: https://pan.baidu.com/s/1yK09mb6LmGqgOP4dT4QZEA<br>
提取码: xes9</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 CSP 初赛模拟题及答案]]></title>
        <id>https://wyyszl.github.io/post/2020-csp-chu-sai-mo-ni-ti-ji-da-an/</id>
        <link href="https://wyyszl.github.io/post/2020-csp-chu-sai-mo-ni-ti-ji-da-an/">
        </link>
        <updated>2020-10-09T14:23:25.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://luogu-ipic.oss-cn-shanghai.aliyuncs.com/2020autumn/2020%20%E6%B4%9B%E8%B0%B7%E5%88%9D%E8%B5%9B%E6%A8%A1%E6%8B%9F.pdf">试题</a></p>
<p><a href="https://www.luogu.com.cn/problem/U134036?contestId=34867">提交</a></p>
<p>答案：     ABCBACABCBDBACDFTTTBAFFTTAAFFFTCCCDDACCBDCB</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2758]]></title>
        <id>https://wyyszl.github.io/post/p2758/</id>
        <link href="https://wyyszl.github.io/post/p2758/">
        </link>
        <updated>2020-10-09T14:22:58.000Z</updated>
        <content type="html"><![CDATA[<p>/*<br>
lcs<br>
WA</p>
<p>反例:<br>
abcdf<br>
abdef<br>
*/</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;

char a[2005];
char b[2005];
int f[2005][2005];
int main(){
	ios::sync_with_stdio(0);
	scanf(&quot;%s&quot;,a+1);
	scanf(&quot;%s&quot;,b+1);
	int lena=strlen(a+1);
	int lenb=strlen(b+1);
	for(int i=1;i&lt;=lena;++i){
		for(int j=1;j&lt;=lenb;++j){
			if(not(a[i]-b[j])){
				f[i][j]=f[i-1][j-1]+1;
			}else {
				f[i][j]=max(f[i-1][j],f[i][j-1]);
			}
		}
	}
	cout&lt;&lt;max(lena,lenb)-f[lena][lenb];
	return 0;
}

</code></pre>
<h4 id="正解">正解:</h4>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">;</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mo>=</mo><mi>b</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo><mo>+</mo><mn>1</mn><mo separator="true">;</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(x)=\begin{cases}f[i-1][j-1];&amp;a[i]==b[j]\\min(f[i][j-1],f[i-1][j],f[i-1][j-1])+1;&amp;otherwise\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">;</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">;</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些比较（待完善）]]></title>
        <id>https://wyyszl.github.io/post/yi-xie-bi-jiao-dai-wan-shan/</id>
        <link href="https://wyyszl.github.io/post/yi-xie-bi-jiao-dai-wan-shan/">
        </link>
        <updated>2020-10-09T14:22:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-输入输出比较">一、输入输出比较</h2>
<h4 id="1输入整形以-2147483647-为例">1.输入整形（以 2147483647 为例）</h4>
<ul>
<li>无优化 cin：1 time=0.005684 ms，1 s=175932 times</li>
<li>有优化 cin 1 time=0.001723 ms，1 s=580383 times</li>
<li>scanf：1time=0.002501 ms，1s=399840  times</li>
<li>快读：1time=0.000978ms，1s=1024590 times</li>
</ul>
<h4 id="2输出整形以-2147483647-为例">2.输出整形（以 2147483647 为例）</h4>
<ul>
<li>无优化 cout：1 time=0.001498 ms，1 s=667557 times</li>
<li>有优化 cout：1time=0.001522ms，1 s=657030 times（我感觉加了个假优化(((）</li>
<li>printf ：1 time=0.004952ms，1s=201939 times</li>
<li>快写：1time =0.001519 ms，1s=658328 times（这能叫快写？）</li>
</ul>
<h4 id="3输出字符串10-位">3.输出字符串(10 位)</h4>
<ul>
<li>cout:1time=0.0004658ms,1s = 2146844 times</li>
<li>printf: 1time=0.0038ms,1s= 263157 times</li>
<li>putchar:1time=0.0009758ms,1s= 1024700 times</li>
<li>puts:1time=0.000208 ms,1s= 4807692 times</li>
</ul>
<h4 id="4输出换行">4.输出换行</h4>
<ul>
<li>cout&lt;&lt;'\n':1 time=0.0002811ms,1s= 3557453 times</li>
<li>cout&lt;&lt;endl:1 time=0.002866 ms,1s= 348918 times(同是 cout 生，为何慢 10 倍。。。)</li>
<li>printf：1 time=0.002913 ms,1s= 343289 times</li>
<li>puts:1time=0.0001314 ms,1s= 7610350 times</li>
</ul>
<h2 id="二-i-i">二、++i &amp; i++</h2>
<ul>
<li>++i: 1time=0.000002121 ms,1s= 471475719 times</li>
<li>i++:1time=0.000002473 ms,1s= 404367165 times</li>
</ul>
<h2 id="三-ri-int">三、ri &amp; int</h2>
<ul>
<li>register int: 1time=0.000002121 ms,1s= 471475719 times</li>
<li>int:1 time=0.00000248 ms,1s= 403225806 times</li>
</ul>
<h2 id="四-stl-手写">四、stl &amp; 手写</h2>
<h2 id="五-位运算">五、位运算 &amp; * /</h2>
<h2 id="六-signed-unsigned">六、signed &amp; unsigned</h2>
<h3 id="注所有测试都在性能较差的-windows7-电脑下进行">注：所有测试都在性能较差的 Windows7 电脑下进行</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[花神游历各国]]></title>
        <id>https://wyyszl.github.io/post/hua-shen-you-li-ge-guo/</id>
        <link href="https://wyyszl.github.io/post/hua-shen-you-li-ge-guo/">
        </link>
        <updated>2020-10-09T14:21:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="原题链接"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1550">原题链接</a></h3>
<p>解题思路：<br>
考虑到区间开根号不好维护区间和，即 sum 值不易维护，不能使用延迟标记来区间修改，只能单点修改。单点修改的时间复杂度乍一看是 O(n·m·logn)，但这道题有一定的特征，其特征主要在于开根号的一些特征： \sqrt{1}=1    \sqrt{0}=0。 因而如果一个节点表示的区间都为 1 or 0，那么这个节点和其所有子节点就无需更改。对于每一个非负数，进行数次操作后都可以变为 0 or 1。又因为题目中<code>每个数开平方(下取整)</code>,所以我们对于每一个数仅需要 &lt;= 6 次操作就可以变为 1 or 0 。综上，我们可以把区间修改改为单点修改，搜到一个表示的区间都为 1 or 0 的点就停止操作，而区间查询正常。<br>
解题细节：<br>
1.如何确定一个区间书否都是 1 or 0：打标记或维护最大值（我使用前者，但事实上后者方便一些）。</p>
<h3 id="综上便有了以下错误代码">综上，便有了以下错误代码：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;
int n,m;
int a[100005];
int x,l,r;
struct P{
   int l,r;
   int sum;
   bool flag;
}tree[400050];
void pushup(int t){
   tree[t].sum =tree[t*2].sum +tree[t*2+1].sum ;
   if(tree[t*2].flag and tree[t*2+1].flag )tree[t].flag=1;
   if(tree[t].flag ) tree[t].sum =tree[t].r-tree[t].l+1;
   return;
}
void build(int t,int l,int r){
   tree[t].l =l;
   tree[t].r =r;
   if(l==r){
   	tree[t].sum =a[l];
   	if(l==1)tree[t].flag=1;
   	return;
   }
   int mid=(l+r)/2.0;
   build(t*2,l,mid);
   build(t*2+1,mid+1,r);
   pushup(t);
   return;
}
int qcheck(int t,int l,int r){
   if(l&lt;=tree[t].l and tree[t].r &lt;=r){
   	return tree[t].sum ;
   }
   int mid=(tree[t].l +tree[t].r)/2.0;
   int ans=0;
   if(l&lt;=mid)ans=qcheck(t*2,l,r);
   if(r&gt;mid)ans+=qcheck(t*2+1,l,r);
   return ans;
}
void cnote(int t,int l){
   if(tree[t].l ==tree[t].r ){
   	tree[t].sum =sqrt(tree[t].sum );
   	if(not(tree[t].sum -1) )tree[t].flag=1;
   	return;
   }
   int mid=(tree[t].l +tree[t].r )/2.0;
   if(l&lt;=mid)cnote(t*2,l);
   else cnote(t*2+1,l);
   pushup(t);
   return;
}
int main(){
   ios::sync_with_stdio(0);
   cin&gt;&gt;n;
   for(int i=1;i&lt;=n;++i){
   	cin&gt;&gt;a[i];
   }
   build(1,1,n);
   cin&gt;&gt;m;
   for(int i=1;i&lt;=m;++i){
   	cin&gt;&gt;x&gt;&gt;l&gt;&gt;r;
   	if(not(x-1)){
   		cout&lt;&lt;qcheck(1,l,r)&lt;&lt;endl;;
   	}else{
   		for(int j=l;j&lt;=r;++j){
   			cnote(1,j);
   		}
   	}
   }
   return 0;
}
</code></pre>
<h4 id="tle-20pts">TLE 20pts</h4>
<p>根据上面的分析，该代码的复杂度应该为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>k</mi><mtext> </mtext><mi>m</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(k~m~logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace nobreak"> </span><span class="mord mathdefault">m</span><span class="mspace nobreak"> </span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> ,但该代码在枚举单点修改时复杂度已经达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mtext> </mtext><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n~m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace nobreak"> </span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 。<br>
细节2：单点修改要和区间修改融合而不是直接枚举修改。</p>
<h2 id="错误代码2">错误代码2：</h2>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
int n,m;
int a[100005];
int x,l,r;
struct P {
	int l,r;
	int sum;
	bool flag;
} tree[400050];
void pushup(int t) {
	tree[t].sum =tree[t*2].sum +tree[t*2+1].sum ;
	if(tree[t*2].flag and tree[t*2+1].flag )tree[t].flag=1;
  if(tree[t].flag)tree[t].sum=tree[t].r-tree[t].l+1;
	return;
}
void build(int t,int l,int r) {
	tree[t].l =l;
	tree[t].r =r;
	if(l==r) {
		tree[t].sum =a[l];
		if(a[l]==1 or (not a[l]))tree[t].flag=1;
		return;
	}
	int mid=(l+r)/2.0;
	build(t*2,l,mid);
	build(t*2+1,mid+1,r);
	pushup(t);
	return;
}
int qcheck(int t,int l,int r) {
	if(l&lt;=tree[t].l and tree[t].r &lt;=r) {
		return tree[t].sum ;
	}
	int mid=(tree[t].l +tree[t].r)/2.0;
	int ans=0;
	if(l&lt;=mid)ans=qcheck(t*2,l,r);
	if(r&gt;mid)ans+=qcheck(t*2+1,l,r);
	pushup(t);
	return ans;
}
void cnote(int t,int l,int r) {
	if(tree[t].flag )return;
	if(tree[t].l ==tree[t].r ) {
		tree[t].sum =(int)sqrt(tree[t].sum );
		if(not(tree[t].sum -1) or not(tree[t].sum ))tree[t].flag=1;
		return;
	}
	int mid=(tree[t].l +tree[t].r )/2.0;
	if(l&lt;=mid)cnote(t*2,l,r);
	if(r&gt;mid) cnote(t*2+1,l,r);
	pushup(t);
	return;
}
signed main() {
//	freopen(&quot;11.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;11.out&quot;,&quot;w&quot;,stdout);
    ios::sync_with_stdio(0);
	cin&gt;&gt;n;
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;a[i];
	}
	build(1,1,n);
	cin&gt;&gt;m;
	for(int i=1; i&lt;=m; ++i) {
		cin&gt;&gt;x&gt;&gt;l&gt;&gt;r;
		if(not(x-1)) {
			cout&lt;&lt;qcheck(1,l,r)&lt;&lt;endl;;;;;;;;;
		} else {
			if(l&gt;r){
				l xor_eq r;
				r xor_eq l;
				l xor_eq r;
			}
			cnote(1,l,r);
		}
	}
	return 0;
}
</code></pre>
<p>该代码问题在于这句话：<code>if(tree[t].flag)tree[t].sum=tree[t].r-tree[t].l+1;</code>这行代码忽略了数字为 0 的情况。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>    </mtext></mrow><annotation encoding="application/x-tex">~~~~</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span></span></span></span>细节3：数字可能为 0。</p>
<h2 id="ac-代码">AC 代码：</h2>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
int n,m;
int a[100005];
int x,l,r;
struct P {
	int l,r;
	int sum;
	bool flag;
} tree[400050];
void pushup(int t) {
	tree[t].sum =tree[t*2].sum +tree[t*2+1].sum ;
	if(tree[t*2].flag and tree[t*2+1].flag )tree[t].flag=1;
	return;
}
void build(int t,int l,int r) {
	tree[t].l =l;
	tree[t].r =r;
	if(l==r) {
		tree[t].sum =a[l];
		if(a[l]==1 or (not a[l]))tree[t].flag=1;
		return;
	}
	int mid=(l+r)/2.0;
	build(t*2,l,mid);
	build(t*2+1,mid+1,r);
	pushup(t);
	return;
}
int qcheck(int t,int l,int r) {
	if(l&lt;=tree[t].l and tree[t].r &lt;=r) {
		return tree[t].sum ;
	}
	int mid=(tree[t].l +tree[t].r)/2.0;
	int ans=0;
	if(l&lt;=mid)ans=qcheck(t*2,l,r);
	if(r&gt;mid)ans+=qcheck(t*2+1,l,r);
	pushup(t);
	return ans;
}
void cnote(int t,int l,int r) {
	if(tree[t].flag )return;
	if(tree[t].l ==tree[t].r ) {
		tree[t].sum =(int)sqrt(tree[t].sum );
		if(not(tree[t].sum -1) or not(tree[t].sum ))tree[t].flag=1;
		return;
	}
	int mid=(tree[t].l +tree[t].r )/2.0;
	if(l&lt;=mid)cnote(t*2,l,r);
	if(r&gt;mid) cnote(t*2+1,l,r);
	pushup(t);
	return;
}
signed main() {
//	freopen(&quot;11.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;11.out&quot;,&quot;w&quot;,stdout);
    ios::sync_with_stdio(0);
	cin&gt;&gt;n;
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;a[i];
	}
	build(1,1,n);
	cin&gt;&gt;m;
	for(int i=1; i&lt;=m; ++i) {
		cin&gt;&gt;x&gt;&gt;l&gt;&gt;r;
        if(l&gt; r) swap(l,r);
		if(not(x-1)) {
			cout&lt;&lt;qcheck(1,l,r)&lt;&lt;endl;;;;;;;;;
		} else {
			cnote(1,l,r);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[模板(待完善)]]></title>
        <id>https://wyyszl.github.io/post/mo-ban-dai-wan-shan/</id>
        <link href="https://wyyszl.github.io/post/mo-ban-dai-wan-shan/">
        </link>
        <updated>2020-10-09T14:21:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c常用模版">C++常用模版</h1>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

class s_r {//快读
	private:
	public:
		inline int read();
};
class s_w {//快写
	private:
	public:
		inline void write(int X);
};
class dfss {//DFS
	private:
		int n;
		int a[25];
		int b[25];
		void dfs(int t);
	public:
		void main();
};
inline int s_r::read() {
	int x=0,f=1;
	char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9') {
		x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
inline void s_w::write(int X) {
	if(X&lt;0) {
		X=~(X-1);
		putchar('-');
	}
	if(X&gt;9) write(X/10);
	putchar(X%10+'0');
	return;
}
void dfss::dfs(int t) {
	if(t==n+1) {
		for(int i=1; i&lt;=n; ++i) {
			cout&lt;&lt;a[i]&lt;&lt;' ';
		}
		cout&lt;&lt;endl;
		return ;
	}
	for(int i=1; i&lt;=n; ++i) {
		if(!b[i]) {
			b[i]=1;
			a[t]=i;
			dfs(t+1);
			b[i]=0;
		}
	}
	return ;
}
void dfss::main () {
	cin&gt;&gt;n;
	dfs(1);
}
</code></pre>
]]></content>
    </entry>
</feed>