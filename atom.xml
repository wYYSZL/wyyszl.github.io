<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wyyszl.github.io</id>
    <title>wYYSZL 的博客</title>
    <updated>2021-01-21T10:46:04.007Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wyyszl.github.io"/>
    <link rel="self" href="https://wyyszl.github.io/atom.xml"/>
    <subtitle>祝大家 csp ++score and  ++rp！</subtitle>
    <logo>https://wyyszl.github.io/images/avatar.png</logo>
    <icon>https://wyyszl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, wYYSZL 的博客</rights>
    <entry>
        <title type="html"><![CDATA[珂朵莉树]]></title>
        <id>https://wyyszl.github.io/post/ke-duo-li-shu/</id>
        <link href="https://wyyszl.github.io/post/ke-duo-li-shu/">
        </link>
        <updated>2021-01-21T10:45:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一名字由来">一，名字由来</h2>
<p>在太阳西斜的这个世界里<br>
置身天上之森<br>
等这场战争结束之后<br>
不归之人与<br>
望眼欲穿的众人</p>
<p>人人本着正义之名<br>
长存不灭的过去<br>
逐渐消逝的未来<br>
我回来了<br>
纵使日薄西山<br>
即便看不到未来<br>
此时此刻的光辉<br>
盼君勿忘</p>
<p>——世界上最幸福的女孩：珂朵莉</p>
<p>“珂朵莉”是动漫《末日时在干什么？有没有空？可以来拯救吗？》的主人公。</p>
<p>一个关于爱情，牺牲，救赎的悲剧动漫的主人公。</p>
<p><s>闲扯一句：最近很闲，看了看那动漫，感觉好酸啊，酸完后又让人很哀伤</s>—— 不过那写（拍）得真的很好。</p>
<p>扯回来，至于为什么以主人公为名，说法不一。</p>
<p>我比较认同的是说有一道题：<a href="https://www.luogu.com.cn/problem/CF896C">CF896C</a>，有位 OIer 用此题发明了一个算法，此题背景有关珂朵莉，而此人又是珂朵莉迷，因而命名为珂朵莉树。</p>
<p>他也使 OI 与 珂朵莉 联系起来。。。</p>
<p>事实上，珂朵莉树是一个“野”算法，即它不像其他算法是被各界承认的。</p>
<p>但它有其作用。</p>
<h2 id="二-它可以干什么">二、它可以干什么</h2>
<p>很简单，在具有区间赋值操作，区间统计操作，以及最好保证<strong>数据随机</strong>的情况下在时空复杂度上把线段树吊起来打（详情见后）。<br>
也可以在走投无路时 <strong>骗分</strong>。</p>
<h2 id="三-你需要有哪些前置知识">三、你需要有哪些前置知识</h2>
<ul>
<li>五分钟就能学会的C++STL中set的部分内容</li>
<li>暴力枚举</li>
<li>数学知识（如果你想证明它的玄学复杂度的话）</li>
</ul>
<h2 id="四-实现">四、实现</h2>
<h3 id="各种声明以及初始化">各种声明以及初始化</h3>
<h4 id="珂朵莉树的节点">珂朵莉树的节点</h4>
<pre><code>typedef bool type;

struct Node
{
	unsigned int l;
	unsigned int r;
	mutable type data;
	Node(unsigned int a, unsigned int b = 0, type c = 0);
	bool operator &lt;(const Node &amp;a) const
	{
		return l &lt; a.l;
	}
};

Node::Node(unsigned int a, unsigned int b, type c)
{
 l = a;
 r = b;
 data = c;
}
</code></pre>
<p>解释一下上面的代码。</p>
<ul>
<li>珂朵莉树的每一个节点代表着一个闭区间，那么Node结构体里理应有这个区间的左右边界（即l和r）。</li>
<li>type和data是当前区间统一的类型与数值，就是说闭区间[l,r]内每个点的类型都是type（自己定义的，这里我使用了bool作为type，到底是什么无所谓），值都是data。（当然，我们只考虑离散的点）</li>
<li>data需要mutable修饰，这样我们可以在set中利用迭代器修改它。</li>
<li>对于结构体，我们自然需要构造函数，无需多讲。</li>
<li>由于我们使用set来存储Node，所以我们需要重载小于号，使其按照左端点排序。</li>
</ul>
<h4 id="构造珂朵莉树">构造珂朵莉树</h4>
<pre><code>#include &lt;set&gt;
set&lt;Node&gt; s;
</code></pre>
<p><s>没错这就完事了</s></p>
<p>就这么简单，你得到了一个没有初始化的珂朵莉树。</p>
<p>一般来说，我们通过给定数据，向其中不断插入区间长度为1的区间来完成初始化。</p>
<p>比如形如这样的话：“第二行包括n个数，表示序列的初始状态”（摘自SCOI2010 序列操作）。</p>
<p>我们就可以这样初始化：</p>
<pre><code>for (int i = 0; i &lt; n; ++i)
 {
 	static type temp = 0;
 	cin &gt;&gt; temp;
 	s.insert(Node(i, i, temp));
 }
 s.insert(Node(n, n, 0));
</code></pre>
<p>你的序列下标从0或者1开始是无所谓的。</p>
<p>这里有一个蜜汁细节，就是在把所有给定数据插入完成之后，需要在末尾多插入一个节点。我也不知道这究竟有啥用，根据自己测试貌似做不做这一步并没有什么区别，<s>反正是玄学，信就完事了。</s></p>
<h4 id="懒人宏定义">懒人宏定义</h4>
<p>我个人并不是很懒，但是声明迭代器真的很令人痛苦。于是我选择了这样</p>
<pre><code>#define S_IT set&lt;Node&gt;::iterator	//S_IT = set_iterator
</code></pre>
<p>据我所知，这个宏定义是大部分写珂朵莉树的OIer都选择了的。</p>
<p>你也可以自己搞一些更懒的宏定义。</p>
<p>至此，准备工作结束。</p>
<h3 id="核心操作">核心操作</h3>
<h4 id="分裂split">分裂：split</h4>
<p>既然我们要进行区间操作，那就得把这个区间拿出来（就是这么暴力的思想） 。<br>
split(pos)操作将包含位置pos的区间[l,r]分裂成[l,pos-1]和[pos,r]，并返回后者的迭代器。</p>
<pre><code>S_IT split(unsigned int pos)
{
 S_IT it = s.lower_bound(Node(pos));
 if (it != s.end() &amp;&amp; it-&gt;l == pos)
  return it;
 --it;
 unsigned int l = it-&gt;l, r = it-&gt;r;
 type data = it-&gt;data;
 s.erase(it);
 s.insert(Node(l, pos - 1, data));
 return s.insert(Node(pos, r, data)).first;
}
</code></pre>
<p>我们先利用lower_bound()函数在set中查到左端点位置大于等于pos的节点。</p>
<p>如果这个节点的左端点位置正是pos，那么我们无需分裂，直接返回。</p>
<p>如果它的左端点位置不是pos，那么必然大于pos，则包含位置pos的节点是上一个节点，it-=1。</p>
<p>接下来的事情就好办了，暴力分裂再插入即可。不要忘了返回值。</p>
<p>此时，如果我们想使用区间[l,r]中的数据，只需要这么写：</p>
<pre><code>S_IT it2 = split(r + 1), it1 = split(l);
 for (; it1 != it2; ++it1)
 {
  ；	//利用迭代器it1搞些事情
 }
</code></pre>
<p>这里有一个细节必须注意，必须先声明it2再声明it1，否则根据split中的erase操作，迭代器it1可能会失效。（因为it1所属的节点可能被删除了）</p>
<h4 id="区间赋值assign">区间赋值：assign</h4>
<p>珂朵莉树最重要的操作，也是不让它退化为暴力算法的玄学 保障。</p>
<p>既然一个区间内所有的值全都一样了，那么在珂朵莉树中这个区间就可以只用一个节点来表示。这就是珂朵莉树的核心，光速降低节点数量的神器。</p>
<pre><code>void assign(unsigned int l, unsigned int r, type val)
{
 S_IT it2 = split(r + 1), it1 = split(l);
 s.erase(it1, it2);
 s.insert(Node(l, r, val));
 return;
}
</code></pre>
<p>可见，这个区间里所有的节点全部被删除，使用一个新的节点来代替。</p>
<p>根据我并不会的 证明，assign的区间长度在随机数据下的期望为N/3，十分恐怖。</p>
<p>而且这个assign在赋值之余还可以顺便做做区间统计啥的，根据情况而定</p>
<p>至此，珂朵莉树的核心操作介绍完毕。</p>
<p>附加的工作？<br>
很多时候，一道题不可能只用两个函数就轻松搞定，需要额外的暴力函数与算法，是的就是暴力。</p>
<p>由于暴力算法大家肯定会，又怕大家不好理解，所以在这里贴一下大佬写的的CF896C的代码。</p>
<p>这道题虽说是起源，但是还是比较有难度的，认为太难的可以直接往下走，看另一个例子。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;vector&gt;

using namespace std;

#define S_IT set&lt;Node&gt;::iterator
typedef long long ll;

struct Node
{
	int l, r;
	mutable ll val;
	bool operator &lt;(const Node &amp;a) const
	{
		return l &lt; a.l;
	}
	Node(int a, int b, ll v);
	Node(int a);
};

S_IT split(int pos);
void add(int l, int r, int v);
ll kth(int l, int r, int k);
ll qpow(ll a, int b, ll y);
ll query(int l, int r, int x, ll y);
void assign(int l, int r, int v);
int rnd(void);

set&lt;Node&gt; s;
ll seed;
int n, m, vmax;

int main(void)
{
	ios::sync_with_stdio(false);
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; seed &gt;&gt; vmax;
	for (int i = 1; i &lt;= n; ++i)
	{
		static int temp = 0;
		temp = rnd() % vmax + 1;
		s.insert(Node(i, i, (ll)temp));
	}
	s.insert(Node(n + 1, n + 1, 0));
	for (int i = 1; i &lt;= m; ++i)
	{
		static int l = 0, r = 0, x = 0, y = 0, op = 0;
		op = rnd() % 4 + 1;
		l = rnd() % n + 1, r = rnd() % n + 1;
		if (l &gt; r)
		{
			swap(l, r);
		}
		if (op == 3)
		{
			x = rnd() % (r - l + 1) + 1;
		}
		else
		{
			x = rnd() % vmax + 1;
		}
		if (op == 4)
		{
			y = rnd() % vmax + 1;
		}
		
		if (op == 1)
		{
			add(l, r, (ll)x);
		}
		else if (op == 2)
		{
			assign(l, r, (ll)x);
		}
		else if (op == 3)
		{
			cout &lt;&lt; kth(l, r, x) &lt;&lt; endl;
		}
		else if (op == 4)
		{
			cout &lt;&lt; query(l, r, x, (ll)y) &lt;&lt; endl;
		}
	}
	//system(&quot;pause&quot;);
	return 0;
}

Node::Node(int a, int b, ll v)
{
	l = a;
	r = b;
	val = v;
}

Node::Node(int a)
{
	l = a;
}

S_IT split(int pos)
{
	S_IT it = s.lower_bound(Node(pos));
	if (it != s.end() &amp;&amp; it-&gt;l == pos)
	{
		return it;
	}
	--it;
	int l = it-&gt;l, r = it-&gt;r;
	ll val = it-&gt;val;
	s.erase(it);
	s.insert(Node(l, pos - 1, val));
	return s.insert(Node(pos, r, val)).first;
}

void add(int l, int r, int v)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	for (S_IT it=it1; it != it2; ++it)
	{
		it-&gt;val += v;
	}
}

ll kth(int l, int r, int k)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	vector&lt;pair&lt;ll, int&gt; &gt;arr;
	arr.clear();
	for (S_IT it = it1; it != it2; ++it)
	{
		arr.push_back(pair&lt;ll, int&gt;(it-&gt;val, it-&gt;r - it-&gt;l + 1));
	}
	sort(arr.begin(), arr.end());
	for (unsigned int i = 0; i &lt; arr.size(); ++i)
	{
		k -= arr[i].second;
		if (k &lt;= 0)
		{
			return arr[i].first;
		}
	}
}

ll qpow(ll a, int x, ll y)
{
	ll b = 1LL;
	a %= y;
	while (x)
	{
		if (x &amp; 1)
		{
			b = (b*a) % y;
		}
		a = (a*a) % y;
		x &gt;&gt;= 1;
	}
	return b;
}

ll query(int l, int r, int x, ll y)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	ll res = 0;
	for (S_IT it = it1; it != it2; ++it)
	{
		res = (res + (it-&gt;r - it-&gt;l + 1)*qpow(it-&gt;val, x, y)) % y;
	}
	return res;
}

void assign(int l, int r, int v)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	s.erase(it1, it2);
	s.insert(Node(l, r, v));
}

int rnd(void) 
{
	int ret = (int)seed;
	seed = (seed * 7 + 13) % 1000000007;
	return ret;
}
</code></pre>
<p>SCOI2010 序列操作也是可以用珂朵莉树暴力写出来的一道题，尽管数据不随机。</p>
<p>这道题相比之下简单一些额外的操作较少，各个函数也比较容易理解。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;

using namespace std;

#define S_IT set&lt;Node&gt;::iterator
#define MAXN 100002
typedef long long ll;
typedef bool type;

struct Node
{
	unsigned int l;
	unsigned int r;
	mutable type data;
	Node(unsigned int a, unsigned int b = 0, type c = 0);
	bool operator &lt;(const Node &amp;a) const
	{
		return l &lt; a.l;
	}
};

S_IT split(unsigned int pos);
void assign(unsigned int l, unsigned int r, type val);
void rev(unsigned int l, unsigned int r);
int sum(unsigned int l, unsigned int r);
int count(unsigned int l, unsigned int r);

set&lt;Node&gt; s;

int main(void)
{
	ios::sync_with_stdio(false);
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; n; ++i)
	{
		static type temp = 0;
		cin &gt;&gt; temp;
		s.insert(Node(i, i, temp));
	}
	s.insert(Node(n, n, 0));
	while (m--)
	{
		static unsigned int op = 0, a = 0, b = 0;
		cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;
		if (op == 0)
		{
			assign(a, b, 0);
		}
		else if (op == 1)
		{
			assign(a, b, 1);
		}
		else if (op == 2)
		{
			rev(a, b);
		}
		else if (op == 3)
		{
			cout &lt;&lt; sum(a, b) &lt;&lt; endl;
		}
		else
		{
			cout &lt;&lt; count(a, b) &lt;&lt; endl;
		}
	}
	system(&quot;pause&quot;);
	return 0;
}

Node::Node(unsigned int a, unsigned int b, type c)
{
	l = a;
	r = b;
	data = c;
}

S_IT split(unsigned int pos)
{
	S_IT it = s.lower_bound(Node(pos));
	if (it != s.end() &amp;&amp; it-&gt;l == pos)
		return it;
	--it;
	unsigned int l = it-&gt;l, r = it-&gt;r;
	type data = it-&gt;data;
	s.erase(it);
	s.insert(Node(l, pos - 1, data));
	return s.insert(Node(pos, r, data)).first;
}

void assign(unsigned int l, unsigned int r, type val)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	s.erase(it1, it2);
	s.insert(Node(l, r, val));
	return;
}

void rev(unsigned int l, unsigned int r)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	for (; it1 != it2; ++it1)
	{
		it1-&gt;data ^= 1;
	}
}

int sum(unsigned int l, unsigned int r)
{
	S_IT it2 = split(r + 1), it1 = split(l);
	int res = 0;
	for (; it1 != it2; ++it1)
	{
		res += it1-&gt;data ? it1-&gt;r - it1-&gt;l + 1 : 0;
	}
	return res;
}

int count(unsigned int l, unsigned int r)
{
	int res = 0, temp = 0;
	S_IT it2 = split(r + 1), it1 = split(l);
	for (; it1 != it2; ++it1)
	{
		if (it1-&gt;data)
		{
			temp += it1-&gt;r - it1-&gt;l + 1;

		}
		else
		{
			res = max(res, temp);
			temp = 0;
		}
	}
	return max(res, temp);	
}
</code></pre>
<p>最后的话</p>
<p>根据数学（玄）分析，珂朵莉树的各种操作的总体复杂度始终为O(NlogN)，这会吊打某些常数大，附加工作会影响总体复杂度的线段树算法。</p>
<p>举个例子，洛谷P2787，有两种写法，线段树和珂朵莉树。<br>
先看看一个ren（我并不认识）的线段树代码（注意右上角的耗时与内存）<br>
被吊打的线段树<br>
然后是我的珂朵莉树代码（我开了O2优化，不开的话用时增加0.5倍左右）。</p>
<p>在这里插入图片描述</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/2019080211051081.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NDX2RzbQ==,size_16,color_FFFFFF,t_70" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20190802110643184.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NDX2RzbQ==,size_16,color_FFFFFF,t_70" alt="" loading="lazy"></figure>
<p>线段树被吊打。</p>
<p>至此，你大致了解完了珂朵莉树的全部基本操作。</p>
<h2 id="五-优缺点">五、优缺点</h2>
<p>1.珂朵莉树在某些情况下可以吊打线段树；柯朵丽树是目前唯一一个可以处理幂次方的树形算法；珂朵莉树可以骗分。</p>
<p>2.珂朵莉树的复杂度是极不稳定的，毕竟它是一个暴力操作，它依赖数据，只有在数据<strong>足够随机</strong>时才能达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi mathvariant="normal">（</mi><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">O（n log n）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">）</span></span></span></span></p>
<p>3.<s>还有一点，你在码珂朵莉树时可以调动您的文学细胞；您在码珂朵莉树时可能会感到有些哀伤不适</s></p>
<h2 id="六-题单">六、题单</h2>
<p>以下题目都珂以用珂朵莉树做，但珂朵莉树并不是正解，只是因为数据水才能过</p>
<ul>
<li>1.Luogu CF343D Water Tree</li>
<li>2.Luogu P2572 [SCOI2010]序列操作</li>
<li>3.Luogu P4344 [SHOI2015]脑洞治疗仪</li>
<li>4.Luogu CF915E Physical Education Lessons</li>
<li>5.Luogu P2787 语文1（chin1）- 理理思维</li>
<li>6.Luogu P1204 [USACO1.2]挤牛奶Milking Cows</li>
<li>7.Luogu P4979 矿洞：坍塌</li>
<li>8.Luogu P3740 [HAOI2014]贴海报</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈 hash 表]]></title>
        <id>https://wyyszl.github.io/post/qian-tan-hash-biao/</id>
        <link href="https://wyyszl.github.io/post/qian-tan-hash-biao/">
        </link>
        <updated>2021-01-19T10:31:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="hash-表是什么">hash 表是什么？</h3>
<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<h2 id="为什么要用-hashhash-能干什么">为什么要用 hash（hash 能干什么？）</h2>
<p>想想这个事情：如果百度对于一个人的一次“常搜”推荐需要 10s，那么对于全国网友来说，同时上网的人群基数很高，那么如果服务器性能不好的话，怕不是要三星 note7 qwq？？？</p>
<p>事实上，导致这个问题的主要原因是：判断字符串是否相等（匹配）的复杂度为O（len），判断子串的复杂度可以达到二次。</p>
<p>因此，我们要学习字符串算法。</p>
<p>“纵使现在有很多极好用的算法，但永远无法撼动 hash 表的地位”----教练</p>
<p>所以我们来学习 hash。</p>
<h2 id="整体思路">整体思路：</h2>
<p>比较两个字符串，我们还不会。</p>
<p>但我们知道如何看两个数是否相等。</p>
<p>那么我们可以转化数字。</p>
<p>字符串转数字坑定不能无损（不然你要字符串干什么，而且强行转换复杂度仍很高）。</p>
<p>不卖关子了，直接介绍：哈希的过程，其实可以看作对一个串的<strong>单向加密过程</strong>，并且需要保证所加的密不能<strong>高概率重复</strong>（就像不能让隔壁老王轻易地用它家的钥匙打开你家门一样qwq），通过这种方式来替代一些很费时间的操作。</p>
<p>如何理解呢？</p>
<p>对于每个串，我们通过一个<strong>固定</strong>的转换方式，将相同的串使其的“密”<strong>一定相同</strong>，不同的串 <strong>尽量</strong> 不同。</p>
<p>此处有人指出：那难道不能先比对字符串长度，然后比对ASCLL码之和吗？事实上显然是不行的（比如ab和ba，并不是同一个串，但是如是做却会让其认为是qwq）。这种情况就叫做  <strong><em>hash 冲突</em></strong> ，并且在如此的单向加密哈希中， hash冲突的情况在所难免（bzoj就有这种让你给出一组样例，使得一段哈希代码冲突的题，读者可以尝试尝试）。</p>
<p>而我们此处介绍的，即是最常见的一种哈希：进制哈希。进制哈希的核心便是给出一个固定进制 <strong>base</strong>，将一个串的每一个元素看做一个进制位上的数字，所以这个串就可以看做一个<strong>base</strong>进制的数，那么这个数就是这个串的哈希值；则我们通过比对每个串的的哈希值，即可判断两个串是否相同.</p>
<p>base 一般为 131,13331，19260817 (某伟人生日)，20061113 <s>(不必在意这些细节,质数即可)</s>，其他质数</p>
<p>为什么要用质数，这个文章讲得好：<a href="https://www.cnblogs.com/cryingrain/p/11144225.html">123</a></p>
<h2 id="实现">实现</h2>
<p>luogu P3370</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef unsigned long long ull;
ull base=20061113;
ull a[10010];
char s[10010];
int n,ans=1;
int prime=233317; 
ull mod=212370440130137957ll;
ull hashe(char s[])
{
    int len=strlen(s);
    ull ans=0;
    for (int i=0;i&lt;len;i++)
    ans=(ans*base+(ull)s[i])%mod+prime;
    return ans;
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%s&quot;,s);
        a[i]=hashe(s);
    }
    sort(a+1,a+n+1);
    for(int i=1;i&lt;n;i++)
    {
        if(a[i]!=a[i+1])
        ans++;
    }
    printf(&quot;%d&quot;,ans);
} 
</code></pre>
<p>当然，再好的哈希也会有冲突，此时有两种做法可以解决或者降低哈希冲突的可能性</p>
<h3 id="1-无错哈希">1、无错哈希</h3>
<p>其实原理很简单，就是我们要记录每一个已经诞生的哈希值，然后对于每一个新的哈希值，我们都可以来判断是否和已有的哈希值冲突，如果冲突，那么可以将这个新的哈希值不断加上一个大质数，直到不再冲突。</p>
<p>先贴代码：</p>
<pre><code>for(int i=1;i&lt;=m;i++)//m个串
{
	cin&gt;&gt;str;//下一行的check为bool型 
	while(check[hash(str)])hash[i]+=19260817;
	hash[i]+= hash(str) ;
}
</code></pre>
<p>但是，这种方法类似桶查找，但是桶查找的弊端2就会很恶心——数据过大， check数组无能为力来支持上亿个空间（弊端1是由于数据具有跳跃性，浪费最后的统计次数，但在此不是特别明显）</p>
<h3 id="2-多重哈希">2、多重哈希</h3>
<p>这其实就是你用不同的两种或多种方式哈希，然后分别比对每一种哈希值是否相同——显然是增加了空间和时间，但也确实增加了其正确性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 学习笔记]]></title>
        <id>https://wyyszl.github.io/post/python-xue-xi-bi-ji/</id>
        <link href="https://wyyszl.github.io/post/python-xue-xi-bi-ji/">
        </link>
        <updated>2021-01-19T06:42:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p><s>原因+条件</s>：<br>
1.原因 <s>（必要性）</s>：1.洛谷出台高级团队，我校团队受限。<br>
2.zjx 大佬制造 OJ ，需要有人会造数据。<br>
3.CYaRon 造数据较方便。<br>
2.条件 <s>(可能性)</s>：机房有人会 python。</p>
<h2 id="内容">内容</h2>
<pre><code class="language-python"># 用井字符开头的是单行注释

&quot;&quot;&quot; 多行字符串用三个引号
    包裹，也常被用来做多
    行注释
&quot;&quot;&quot;

########################
##1.运算
########################
# 整数
3  # =&gt; 3

# 算术没有什么出乎意料的
1 + 1  # =&gt; 2
8 - 1  # =&gt; 7
10 * 2  # =&gt; 20

# 但是除法例外，会自动转换成浮点数
35 / 5  # =&gt; 7.0
5 / 3  # =&gt; 1.6666666666666667

# 整数除法的结果都是向下取整
5 // 3     # =&gt; 1
5.0 // 3.0 # =&gt; 1.0 # 浮点数也可以
-5 // 3  # =&gt; -2
-5.0 // 3.0 # =&gt; -2.0

# 浮点数的运算结果也是浮点数
3 * 2.0 # =&gt; 6.0

# 模除
7 % 3 # =&gt; 1

# x的y次方
2**4 # =&gt; 16

# 用括号决定优先级
(1 + 3) * 2  # =&gt; 8

# 布尔值
True
False

# 用not取非
not True  # =&gt; False
not False  # =&gt; True

# 逻辑运算符，注意and和or都是小写
True and False #=&gt; False
False or True #=&gt; True

# 整数也可以当作布尔值
0 and 2 #=&gt; 0
-5 or 0 #=&gt; -5
0 == False #=&gt; True
2 == True #=&gt; False
1 == True #=&gt; True

# 用==判断相等
1 == 1  # =&gt; True
2 == 1  # =&gt; False

# 用!=判断不等
1 != 1  # =&gt; False
2 != 1  # =&gt; True

# 比较大小
1 &lt; 10  # =&gt; True
1 &gt; 10  # =&gt; False
2 &lt;= 2  # =&gt; True
2 &gt;= 2  # =&gt; True

# 大小比较可以连起来！
1 &lt; 2 &lt; 3  # =&gt; True
2 &lt; 3 &lt; 2  # =&gt; False

# 字符串用单引双引都可以
&quot;这是个字符串&quot;
'这也是个字符串'

# 用加号连接字符串
&quot;Hello &quot; + &quot;world!&quot;  # =&gt; &quot;Hello world!&quot;

# 字符串可以被当作字符列表
&quot;This is a string&quot;[0]  # =&gt; 'T'


# None是一个对象
None  # =&gt; None

# 当与None进行比较时不要用 ==，要用is。is是用来比较两个变量是否指向同一个对象。
&quot;etc&quot; is None  # =&gt; False
None is None  # =&gt; True

# None，0，空字符串，空列表，空字典都算是False
# 所有其他值都是True
bool(0)  # =&gt; False
bool(&quot;&quot;)  # =&gt; False
bool([]) #=&gt; False
bool({}) #=&gt; False

####################################################
## 2. 输入输出
####################################################

# 输出很简短
print(&quot;45464564564&quot;)  # =&gt; 456465465
# 变量
print(a)  # =&gt; （a 的值）
## 注意：print 函数自带一个换行符
# 去掉换行符：
print(a,end=' ')    

# 输入：
## 特别注意：py 与 vbs 很像，输入的是字符串

## 这导致两个问题：
## 1.输入后不能直接运算
## 2.不能简单的输入在一行的多个数

# 正常
a=input(&quot;输入 a&quot;)# =&gt; 输入 a
a=int(a)

# 一行两个数：

a,b,c,...=map(int,input().split())
## 这种写法有个好处，他可以直接变为整形

#实现一个输入多个单词，每个单词之间用逗号隔开。

str1,str2,str3....=map(str,input().split(','))
####################################################
## 3.库
####################################################

import turtle #=&gt; 导入 turtle 库


####################################################
## 4. 变量和集合
####################################################

# print是内置的打印函数
print(&quot;I'm Python. Nice to meet you!&quot;)

# 在给变量赋值前不用提前声明
# 传统的变量命名是小写，用下划线分隔单词
some_var = 5
some_var  # =&gt; 5

# 访问未赋值的变量会抛出异常
# 参考流程控制一段来学习异常处理
some_unknown_var  # 抛出NameError

# 用列表(list)储存序列
li = []
# 创建列表时也可以同时赋给元素
other_li = [4, 5, 6]

# 用append在列表最后追加元素
li.append(1)    # li现在是[1]
li.append(2)    # li现在是[1, 2]
li.append(4)    # li现在是[1, 2, 4]
li.append(3)    # li现在是[1, 2, 4, 3]
# 用pop从列表尾部删除
li.pop()        # =&gt; 3 且li现在是[1, 2, 4]
# 把3再放回去
li.append(3)    # li变回[1, 2, 4, 3]

# 列表存取跟数组一样
li[0]  # =&gt; 1
# 取出最后一个元素
li[-1]  # =&gt; 3

# 越界存取会造成IndexError
li[4]  # 抛出IndexError

# 列表有切割语法
li[1:3]  # =&gt; [2, 4]
# 取尾
li[2:]  # =&gt; [4, 3]
# 取头
li[:3]  # =&gt; [1, 2, 4]
# 隔一个取一个
li[::2]   # =&gt;[1, 4]
# 倒排列表
li[::-1]   # =&gt; [3, 4, 2, 1]
# 可以用三个参数的任何组合来构建切割
# li[始:终:步伐]

# 用del删除任何一个元素
del li[2]   # li is now [1, 2, 3]

# 列表可以相加
# 注意：li和other_li的值都不变
li + other_li   # =&gt; [1, 2, 3, 4, 5, 6]

# 用extend拼接列表
li.extend(other_li)   # li现在是[1, 2, 3, 4, 5, 6]

# 用in测试列表是否包含值
1 in li   # =&gt; True

# 用len取列表长度
len(li)   # =&gt; 6


# 元组是不可改变的序列
tup = (1, 2, 3)
tup[0]   # =&gt; 1
tup[0] = 3  # 抛出TypeError

# 列表允许的操作元组大都可以
len(tup)   # =&gt; 3
tup + (4, 5, 6)   # =&gt; (1, 2, 3, 4, 5, 6)
tup[:2]   # =&gt; (1, 2)
2 in tup   # =&gt; True

# 可以把元组合列表解包，赋值给变量
a, b, c = (1, 2, 3)     # 现在a是1，b是2，c是3
# 元组周围的括号是可以省略的
d, e, f = 4, 5, 6
# 交换两个变量的值就这么简单
e, d = d, e     # 现在d是5，e是4

# 用set表达集合
empty_set = set()
# 初始化一个集合，语法跟字典相似。
some_set = {1, 1, 2, 2, 3, 4}   # some_set现在是{1, 2, 3, 4}

# 可以把集合赋值于变量
filled_set = some_set

# 为集合添加元素
filled_set.add(5)   # filled_set现在是{1, 2, 3, 4, 5}

# &amp; 取交集
other_set = {3, 4, 5, 6}
filled_set &amp; other_set   # =&gt; {3, 4, 5}

# | 取并集
filled_set | other_set   # =&gt; {1, 2, 3, 4, 5, 6}

# - 取补集
{1, 2, 3, 4} - {2, 3, 5}   # =&gt; {1, 4}

# in 测试集合是否包含元素
2 in filled_set   # =&gt; True
10 in filled_set   # =&gt; False


####################################################
## 5. 流程控制和迭代器
####################################################

# 先随便定义一个变量
some_var = 5

# 这是个if语句。注意缩进在Python里是有意义的
# 印出&quot;some_var比10小&quot;
if some_var &gt; 10:
    print(&quot;some_var比10大&quot;)
elif some_var &lt; 10:    # elif句是可选的
    print(&quot;some_var比10小&quot;)
else:                  # else也是可选的
    print(&quot;some_var就是10&quot;)


&quot;&quot;&quot;
用for循环语句遍历列表
打印:
    dog is a mammal
    cat is a mammal
    mouse is a mammal
&quot;&quot;&quot;
for animal in [&quot;dog&quot;, &quot;cat&quot;, &quot;mouse&quot;]:
    print(&quot;{} is a mammal&quot;.format(animal))

&quot;&quot;&quot;
&quot;range(number)&quot;返回数字列表从0到给的数字
打印:
    0
    1
    2
    3
&quot;&quot;&quot;
for i in range(4):
    print(i)

&quot;&quot;&quot;
while循环直到条件不满足
打印:
    0
    1
    2
    3
&quot;&quot;&quot;
x = 0
while x &lt; 4:
    print(x)
    x += 1  # x = x + 1 的简写

# 用try/except块处理异常状况
try:
    # 用raise抛出异常
    raise IndexError(&quot;This is an index error&quot;)
except IndexError as e:
    pass    # pass是无操作，但是应该在这里处理错误
except (TypeError, NameError):
    pass    # 可以同时处理不同类的错误
else:   # else语句是可选的，必须在所有的except之后
    print(&quot;All good!&quot;)   # 只有当try运行完没有错误的时候这句才会运行


# Python提供一个叫做可迭代(iterable)的基本抽象。一个可迭代对象是可以被当作序列
# 的对象。比如说上面range返回的对象就是可迭代的。

filled_dict = {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3}
our_iterable = filled_dict.keys()
print(our_iterable) # =&gt; range(1,10) 是一个实现可迭代接口的对象

# 可迭代对象可以遍历
for i in our_iterable:
    print(i)    # 打印 one, two, three

# 但是不可以随机访问
our_iterable[1]  # 抛出TypeError

# 可迭代对象知道怎么生成迭代器
our_iterator = iter(our_iterable)

# 迭代器是一个可以记住遍历的位置的对象
# 用__next__可以取得下一个元素
our_iterator.__next__()  #=&gt; &quot;one&quot;

# 再一次调取__next__时会记得位置
our_iterator.__next__()  #=&gt; &quot;two&quot;
our_iterator.__next__()  #=&gt; &quot;three&quot;

# 当迭代器所有元素都取出后，会抛出StopIteration
our_iterator.__next__() # 抛出StopIteration

# 可以用list一次取出迭代器所有的元素
list(filled_dict.keys())  #=&gt; Returns [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]



####################################################
## 6. 函数
####################################################

# 用def定义新函数
def add(x, y):
    print(&quot;x is {} and y is {}&quot;.format(x, y))
    return x + y    # 用return语句返回

# 调用函数
add(5, 6)   # =&gt; 印出&quot;x is 5 and y is 6&quot;并且返回11

# 也可以用关键字参数来调用函数
add(y=6, x=5)   # 关键字参数可以用任何顺序


# 我们可以定义一个可变参数函数
def varargs(*args):
    return args

varargs(1, 2, 3)   # =&gt; (1, 2, 3)


# 我们也可以定义一个关键字可变参数函数
def keyword_args(**kwargs):
    return kwargs

# 我们来看看结果是什么：
keyword_args(big=&quot;foot&quot;, loch=&quot;ness&quot;)   # =&gt; {&quot;big&quot;: &quot;foot&quot;, &quot;loch&quot;: &quot;ness&quot;}


# 这两种可变参数可以混着用
def all_the_args(*args, **kwargs):
    print(args)
    print(kwargs)
&quot;&quot;&quot;
all_the_args(1, 2, a=3, b=4) prints:
    (1, 2)
    {&quot;a&quot;: 3, &quot;b&quot;: 4}
&quot;&quot;&quot;

# 调用可变参数函数时可以做跟上面相反的，用*展开序列，用**展开字典。
args = (1, 2, 3, 4)
kwargs = {&quot;a&quot;: 3, &quot;b&quot;: 4}
all_the_args(*args)   # 相当于 foo(1, 2, 3, 4)
all_the_args(**kwargs)   # 相当于 foo(a=3, b=4)
all_the_args(*args, **kwargs)   # 相当于 foo(1, 2, 3, 4, a=3, b=4)


# 函数作用域
x = 5

def setX(num):
    # 局部作用域的x和全局域的x是不同的
    x = num # =&gt; 43
    print (x) # =&gt; 43

def setGlobalX(num):
    global x
    print (x) # =&gt; 5
    x = num # 现在全局域的x被赋值
    print (x) # =&gt; 6

setX(43)
setGlobalX(6)


# 函数在Python是一等公民
def create_adder(x):
    def adder(y):
        return x + y
    return adder

add_10 = create_adder(10)
add_10(3)   # =&gt; 13

# 也有匿名函数
(lambda x: x &gt; 2)(3)   # =&gt; True

# 内置的高阶函数
map(add_10, [1, 2, 3])   # =&gt; [11, 12, 13]
filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7])   # =&gt; [6, 7]

# 用列表推导式可以简化映射和过滤。列表推导式的返回值是另一个列表。
[add_10(i) for i in [1, 2, 3]]  # =&gt; [11, 12, 13]
[x for x in [3, 4, 5, 6, 7] if x &gt; 5]   # =&gt; [6, 7]

####################################################
## 7. 类
####################################################


# 定义一个继承object的类
class Human(object):

    # 类属性，被所有此类的实例共用。
    species = &quot;H. sapiens&quot;

    # 构造方法，当实例被初始化时被调用。注意名字前后的双下划线，这是表明这个属
    # 性或方法对Python有特殊意义，但是允许用户自行定义。你自己取名时不应该用这
    # 种格式。
    def __init__(self, name):
        # Assign the argument to the instance's name attribute
        self.name = name

    # 实例方法，第一个参数总是self，就是这个实例对象
    def say(self, msg):
        return &quot;{name}: {message}&quot;.format(name=self.name, message=msg)

    # 类方法，被所有此类的实例共用。第一个参数是这个类对象。
    @classmethod
    def get_species(cls):
        return cls.species

    # 静态方法。调用时没有实例或类的绑定。
    @staticmethod
    def grunt():
        return &quot;*grunt*&quot;


# 构造一个实例
i = Human(name=&quot;Ian&quot;)
print(i.say(&quot;hi&quot;))     # 印出 &quot;Ian: hi&quot;

j = Human(&quot;Joel&quot;)
print(j.say(&quot;hello&quot;))  # 印出 &quot;Joel: hello&quot;

# 调用一个类方法
i.get_species()   # =&gt; &quot;H. sapiens&quot;

# 改一个共用的类属性
Human.species = &quot;H. neanderthalensis&quot;
i.get_species()   # =&gt; &quot;H. neanderthalensis&quot;
j.get_species()   # =&gt; &quot;H. neanderthalensis&quot;

# 调用静态方法
Human.grunt()   # =&gt; &quot;*grunt*&quot;


####################################################
## 8. 模块
####################################################

# 用import导入模块
import math
print(math.sqrt(16))  # =&gt; 4.0

# 也可以从模块中导入个别值
from math import ceil, floor
print(ceil(3.7))  # =&gt; 4.0
print(floor(3.7))   # =&gt; 3.0

# 可以导入一个模块中所有值
# 警告：不建议这么做
from math import *

# 如此缩写模块名字
import math as m
math.sqrt(16) == m.sqrt(16)   # =&gt; True

# Python模块其实就是普通的Python文件。你可以自己写，然后导入，
# 模块的名字就是文件的名字。

# 你可以这样列出一个模块里所有的值
import math
dir(math)


####################################################
## 9. 高级用法（没什么用）
####################################################

# 用生成器(generators)方便地写惰性运算
def double_numbers(iterable):
    for i in iterable:
        yield i + i

# 生成器只有在需要时才计算下一个值。它们每一次循环只生成一个值，而不是把所有的
# 值全部算好。这意味着double_numbers不会生成大于15的数字。
#
# range的返回值也是一个生成器，不然一个1到900000000的列表会花很多时间和内存。
#
# 如果你想用一个Python的关键字当作变量名，可以加一个下划线来区分。
range_ = range(1, 900000000)
# 当找到一个 &gt;=30 的结果就会停
for i in double_numbers(range_):
    print(i)
    if i &gt;= 30:
        break
</code></pre>
<h2 id="总结">总结：</h2>
<p>1.Python 作为一个很受欢迎的语言，它确实有很多优势，例如自带高精度，一些巧妙的语法和大量的自带库，都使得其相当方便。<br>
2.但 Python 也有其劣势，例如输入是极不方便的，不是“编译式语言”以及并不工整的语法，这些导致其不方便。<br>
3.不知道是否因为我习惯 c++，我认为 Python 并不如 c++ 使用起来顺。<br>
4.总的来说，我认为如果 Python 可以足够普及并库足够多，它是一个方便的语言。</p>
<h2 id="意义">意义：</h2>
<p>1.学习了一种新语言<br>
2.客观地认识了 Python。<br>
3.提高了对 c++ 的喜爱程度。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[csp5020-2]]></title>
        <id>https://wyyszl.github.io/post/csp5020-2/</id>
        <link href="https://wyyszl.github.io/post/csp5020-2/">
        </link>
        <updated>2021-01-19T02:45:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="csp-j">csp-j</h1>
<h2 id="t1">t1</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
int i;
int n;
bool b[128];
inline void ini(int a){
	for(i=1;a;++i){
		b[i]=a%2;
		a&gt;&gt;=1;
	}
	return ;
}
int main(){
//	freopen(&quot;power.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;power.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;n;
	ini(n);
	if(b[1]){
		cout&lt;&lt;-1;
		return 0;
	}
	for(;i;--i){
		if(b[i])cout&lt;&lt;(int)pow(2,i-1)&lt;&lt;' ';
	}
	return 0;
}




</code></pre>
<h2 id="t2">t2</h2>
<h3 id="1">1</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
int n,last,l;
int w;
priority_queue&lt;int&gt;dl2;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;dl1;
int main(){
//	freopen(&quot;live.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;live.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;n&gt;&gt;w;
	cin&gt;&gt;l;
	last=l;
	dl1.push(l);
	cout&lt;&lt;l&lt;&lt;' ';
	for(int i=2;i&lt;=n;++i){
		scanf(&quot;%d&quot;,&amp;l);
		if(l&lt;last)dl2.push(l);
		else dl1.push(l);
		if((int)dl1.size()&lt;max(1,(int)(i*w/100.0))){
			int u=dl2.top();
			dl2.pop();
			dl1.push(u);
			last=dl1.top();
		}
		if((int)dl1.size()&gt;max(1,(int)(i*w/100.0))){
			int u=dl1.top();
			dl1.pop();
			dl2.push(u);
			last=dl1.top();
		}
		cout&lt;&lt;last&lt;&lt;' ';
	}
	return 0;
}



</code></pre>
<h3 id="2">2</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
int n,w;
int l;
struct Node {
	int l,r,sum;
} tree[2405];
void build(int t,int l,int r) {
	tree[t].l =l;
	tree[t].r =r;
	tree[t].sum =0;
	if(not(l-r))return ;
	int mid=(l+r)&gt;&gt;1;
	build(t*2,l,mid);
	build(t*2+1,mid+1,r);
	return;
}
void cnote(int t,int l){
	if(not(tree[t].l -tree[t].r )){
		++tree[t].sum;
		return ;
	}
	int mid=(tree[t].l +tree[t].r )&gt;&gt;1;
	if(l&lt;=mid)cnote(t*2,l);
	else cnote(t*2+1,l);
	++tree[t].sum ;
	return ;
}
int ask(int t,int l){
	if(not(tree[t].l -tree[t].r ))return tree[t].l ;
	if(tree[t*2+1].sum &gt;=l)return ask(t*2+1,l);
	else return ask(t*2,l-tree[t*2+1].sum );
}
int main() {
	ios::sync_with_stdio(0);
	cin&gt;&gt;n&gt;&gt;w;
	build(1,1,600);
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;l;
		cnote(1,l);
		int asdf=max(1,i*w/100);
		cout&lt;&lt;ask(1,asdf)&lt;&lt;' ';
	}
	return 0;
}

</code></pre>
<h3 id="3">3</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int t[605];
int n,w;
int main()
{
	int x;
	cin&gt;&gt;n&gt;&gt;w;
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;x;
		t[x]++;
		int sum=0;
		for(int j=600;j&gt;=0;j--)
		{
			sum+=t[j];
			if(sum&gt;=max(1,i*w/100))
			{
				cout&lt;&lt;j&lt;&lt;' ';
				break;
			}
		}
	}
	return 0;
 } 
</code></pre>
<h2 id="t3">t3</h2>
<h3 id="赛时30pts">赛时（30pts）</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
string s[100005];
int i;
int num;
int t[100005];
int len;
int l;
bool q[100005];
int z;
int  ans1,ans2;
int n;
int d[100005];
bool asdf;
stack&lt;int&gt;zh;
bool zjx[100005];
bool check(string s) {
	len=s.size();
	if(!s.size())return 1;
	for(int i=0; i&lt;len; ++i) {
		if(!(s[i]&gt;='0' &amp;&amp; s[i]&lt;='9'))return 1;
	}
	return 0;
}
int main() {
	q[100001]=1;
	q[100002]=0;
	while(++i,cin&gt;&gt;s[i],check(s[i])) {
		len=s[i].size();
		if(s[i]==&quot;&amp;&quot; || s[i]==&quot;|&quot;||s[i]==&quot;!&quot;) {
			char ch=s[i][0];
			switch(ch) {
				case'&amp;' : {
					t[++num]=-1;
					break;
				}
				case'|': {
					t[++num]=-2;
					break;
				}
				default: {
					t[++num]=-3;
					asdf=1;
					break;
				}
			}
		} else {
			l=0;
			for(int j=1; j&lt;len; ++j) {
				l*=10;
				l+=s[i][j]-'0';
			}
			t[++num]=l;
		}
	}
	for(int j=0; j&lt;s[i].size(); ++j) {
		n*=10;
		n+=s[i][j]-'0';
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;q[i];
	}
	for(int j=1; j&lt;=num; ++j) {
		if(t[j]&gt;0) {
			zh.push(t[j]);
		} else {
			if(t[j]&gt;=-2) {
				ans1=zh.top();
				zh.pop();
				ans2=zh.top();
				zh.pop();
			} else {
				ans1=zh.top();
				zh.pop();
			}
			switch(t[j]) {
				case -1 : {
					if(q[ans1] &amp; q[ans2])zjx[ans1]=zjx[ans2]=1;
					if(q[ans1] &amp; !q[ans2])zjx[ans2]=1;
					if(q[ans2] &amp;!q[ans1])zjx[ans1]=1;
					ans1=((q[ans1] &amp;q[ans2])?100001:100002);
					
					break;
				}
				case -2 : {
					if(q[ans1] &amp;q[ ans2])zjx[ans1]=zjx[ans2]=0;
					else if(q[ans1]&amp; !q[ans2])zjx[ans1]=1;
					else if(q[ans2]&amp; !q[ans1])zjx[ans2]=1;
					ans1=((q[ans1 ]| q[ans2])?100001:100002);

					break;
				}
				default: {
					ans1=ans1;
					if(ans1!=100001 and ans1!=100002)q[ans1]=!q[ans1];
					else ans1=(ans1==100001?100002 :100001);
					break;
				}
			}
			zh.push(ans1);
		}
	}
	int djx=q[zh.top()];
	cin&gt;&gt;z;
	for(int i=1;i&lt;=n;++i)cout&lt;&lt;zjx[i]&lt;&lt;' ';
	for(int i=1; i&lt;=z; ++i) {
		cin&gt;&gt;l;
		if(zjx[l])cout&lt;&lt;(!djx)&lt;&lt;endl;
		else cout&lt;&lt;djx&lt;&lt;endl;
	}
	return 0;
}
// Ta&amp;Shan?Zhi@Shi%
</code></pre>
<h3 id="赛后">赛后</h3>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int INF = 0x3f3f3f3f;
const LL mod = 1e9 + 7;
const int N = 1000005;

char s[N];
int a[N];
int son[N][2], ck;
int flag[N], c[N];
int n, q;
int dfs(int u, int g) {
    a[u] ^= g;
    if (u &lt;= n) {
        return a[u];
    }
    int x = dfs(son[u][0], g ^ flag[son[u][0]]);
    int y = dfs(son[u][1], g ^ flag[son[u][1]]);
    if (a[u] == 2) {
        if (x == 0) c[son[u][1]] = 1;
        if (y == 0) c[son[u][0]] = 1;
        return x &amp; y;
    } else {
        if (x == 1) c[son[u][1]] = 1;
        if (y == 1) c[son[u][0]] = 1;
        return x | y;
    }
}
void dfs2(int u) {
    if (u &lt;= n) return;
    c[son[u][0]] |= c[u];
    c[son[u][1]] |= c[u];
    dfs2(son[u][0]);
    dfs2(son[u][1]);
}
int main() {
    // freopen(&quot;expr.in&quot;, &quot;r&quot;, stdin);
    // freopen(&quot;expr.out&quot;, &quot;w&quot;, stdout);
    gets(s);
    scanf(&quot;%d&quot;, &amp;n);
    ck = n;
    for (int i = 1; i &lt;= n; i++) {
        scanf(&quot;%d&quot;, &amp;a[i]);
    }
    stack&lt;int&gt; b;
    for (int i = 0; s[i]; i += 2) {
        if (s[i] == 'x') {
            int x = 0;
            i++;
            while (s[i] != ' ') {
                x = x * 10 + s[i] - '0';
                i++;
            }
            i--;
            b.push(x);
        } else if (s[i] == '&amp;') {
            int x = b.top();
            b.pop();
            int y = b.top();
            b.pop();
            b.push(++ck);
            a[ck] = 2;
            son[ck][0] = x;
            son[ck][1] = y;
        } else if (s[i] == '|') {
            int x = b.top();
            b.pop();
            int y = b.top();
            b.pop();
            b.push(++ck);
            a[ck] = 3;
            son[ck][0] = x;
            son[ck][1] = y;
        } else if(s[i] == '!'){
            flag[b.top()] ^= 1;
        }
    }
    int ans = dfs(ck, flag[ck]);
    dfs2(ck);
    scanf(&quot;%d&quot;, &amp;q);
    while (q--) {
        int x;
        scanf(&quot;%d&quot;, &amp;x);
        printf(&quot;%d\n&quot;, c[x] ? ans : !ans);
    }
    return 0;
}
</code></pre>
<h2 id="t4">t4</h2>
<h3 id="赛时20pts">赛时（20pts）</h3>
<p><s>变量名很皮（都是大佬的名字）</s></p>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
int xty[1005][1005];
int zjx=-0x3f3f3f3f;
bool djx[1005][1005];
int n,m;
int jht;
void dfs(int zkx,int szq,int jht){
	if(zkx&lt;1 || zkx&gt;n ||szq&lt;1 ||szq&gt;m)return;
	if(djx[zkx][szq])return ;
	if(zkx==n &amp;&amp; szq==m){
		zjx=max(zjx,jht);
		return;
	}
	djx[zkx][szq]=1;
	dfs(zkx-1,szq,jht+xty[zkx-1][szq]);
	dfs(zkx+1,szq,jht+xty[zkx+1][szq]);
	dfs(zkx,szq+1,jht+xty[zkx][szq+1]);
	djx[zkx][szq]=0;
}
int main(){
//	freopen(&quot;number.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;number.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;++i){
		for(int j=1;j&lt;=m;++j){
			cin&gt;&gt;xty[i][j];
			if(xty[i][j]&gt;=0)jht+=xty[i][j];
		}
	}
	if(n*m&lt;=35)dfs(1,1,xty[1][1]);
	else{
		cout&lt;&lt;jht;
	}
	cout&lt;&lt;zjx;
	return 0;
}



</code></pre>
<h3 id="赛后-2">赛后：</h3>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
long long n,m,a[1002][1002];
long long f[1002][1002][3];
int main() {
	ios::sync_with_stdio(0);
	cin&gt;&gt;n&gt;&gt;m;
	memset(f,-0x3f,sizeof f);
	for (int i=1; i&lt;=n; ++i)
		for (int j=1; j&lt;=m; ++j) {
			cin&gt;&gt;a[i][j];
		}
	f[1][1][0]=a[1][1];
	for (int i=2; i&lt;=n; ++i) f[i][1][0]=f[i-1][1][0]+a[i][1];
	for (int j=2; j&lt;=m; ++j) {
		f[1][j][1]=f[1][j-1][0]+a[1][j];
		f[n][j][2]=f[n][j-1][0]+a[n][j];
		for (int i=2; i&lt;=n; ++i) {
			f[i][j][1]=max(f[i][j-1][0],f[i-1][j][1])+a[i][j];
		}
		for (int i= n-1; i&gt;0; i--){
			f[i][j][2]=max(f[i][j-1][0],f[i+1][j][2])+a[i][j];
		}
		for (int i=1; i&lt;=n; ++i){
			f[i][j][0]=max(f[i][j][1],f[i][j][2]);
		}
	}
	cout&lt;&lt;f[n][m][0];
	return 0;
}
</code></pre>
<h1 id="csp-s">csp-s</h1>
<h2 id="t1-2">t1</h2>
<h3 id="赛时70pts">赛时（70pts）</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
int T;
int n;
int day ,year,month;
int db[13]= {0,31,28,31,30,31,30,31,31,30,31,30,31};
inline bool check(int q) {
	if(q&gt;0) {
		if(q&gt;1582) {
			if(((q%4==0) &amp;&amp; q%100) || (q%400==0))return 1;
			else return 0;
		} else {
			if(!(q%4))return 1;
			else return 0;
		}
	}
	++q;
	q=-q;
	if(!(q%4))return 1;
	else return 0;
}
struct P {
	int y;
	short m,d;
} pf[10000006];
int main() {

// 	freopen(&quot;julian.in&quot;,&quot;r&quot;,stdin);
// 	freopen(&quot;julian.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;T;
	day=month=1;
	year=-4713;
	db[2]=29;
	for(int i=1; i&lt;=10000000; ++i) {
		++day;
		if(day&gt;db[month]) {
			++month;
			day=1;
		}
		if(month&gt;12) {
			++year;
			if(!year) {
				++year;
			}
			if(check(year))db[2]=29;
			else db[2]=28;
			month=1;
		}
		if(year==1582 &amp;&amp; month==10 &amp;&amp; day==5) {
			day=15;
		}
		pf[i].d =day;
		pf[i].m =month;
		pf[i].y =year;
	}
	while(T--) {
		scanf(&quot;%d&quot;,&amp;n);
		cout&lt;&lt;pf[n].d &lt;&lt;' '&lt;&lt;pf[n].m &lt;&lt;' '&lt;&lt;abs(pf[n].y )&lt;&lt;(pf[n].y &gt;0?&quot; &quot;:&quot; BC&quot;)&lt;&lt;endl;

	}



	return 0;
}


//(ke2YI0gong2YU0)

</code></pre>
<h3 id="赛后-3">赛后</h3>
<pre><code>include&lt;bits/stdc++.h&gt;
#define ll long long
#define int long long //重要 
#define gc getchar
using namespace std;
inline ll read(){
    ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}
    while (isdigit(ch)){x=x*10ll+ch-'0';ch=gc();}
    return x*f;
}
const int mon[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
const int rmon[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
struct que{
    int t,id;
}q[1010101];
struct QWQ{
    int y,m,d;
}ori,tmp,ans[101010],X[300001];
int Q,mx,cnt; 
inline bool cmp(que a,que b){return a.t&lt;b.t;}
inline int mabs(int x){return (x&gt;0?x:-x);}
inline bool isr(QWQ a){
    if (a.y&lt;0) return (-a.y-1)%4==0;
    if (a.y&gt;=1582) return a.y%400==0||(a.y%4==0&amp;&amp;a.y%100);
    if (a.y%4==0) return 1;
    return 0;
}
inline QWQ nextday(QWQ a){ //分类讨论 
    QWQ ans=a;
    if (a.y==1582){
        if (a.m==12&amp;&amp;a.d==31) ans.y++,ans.d=1,ans.m=1;
        else if (a.m==10&amp;&amp;a.d==4) ans.d=15;
        else if (a.d==mon[a.m]) ans.d=1,ans.m++;
        else ans.d++;
        return ans;
    }
    if (a.y==-1&amp;&amp;a.m==12&amp;&amp;a.d==31) ans.y=1,ans.d=1,ans.m=1;    
    else if (isr(a)){
        if (a.m==12&amp;&amp;a.d==31) ans.y++,ans.d=1,ans.m=1;
        else if (a.d==rmon[a.m]) ans.d=1,ans.m++;
        else ans.d++;
    }else{
        if (a.m==12&amp;&amp;a.d==31) ans.y++,ans.d=1,ans.m=1;
        else if (a.d==mon[a.m]) ans.d=1,ans.m++;
        else ans.d++;
    }
    return ans;
}
signed main(){
    ori.y=-4713,ori.m=1,ori.d=1,cnt=-1;
    Q=read();
    for (int i=1;i&lt;=Q;i++) q[i].id=i,q[i].t=read();
    sort(q+1,q+1+Q,cmp);
    tmp=ori;
    for (int i=1;i&lt;=Q;i++){
        if (q[i].t&gt;=2451545) break;
        mx=i; 
    }
    for (int i=1,now=0;i&lt;=mx;i++){
        for (;now!=q[i].t;now++) tmp=nextday(tmp);
        ans[q[i].id]=tmp;
    }
    tmp.d=1,tmp.m=1,tmp.y=2000;
    for (;tmp.y!=2400;) X[++cnt]=tmp,tmp=nextday(tmp);
    for (int i=mx+1;i&lt;=Q;i++){
        ans[q[i].id].d=X[(q[i].t-2451545)%146097].d;
        ans[q[i].id].m=X[(q[i].t-2451545)%146097].m;
        ans[q[i].id].y=X[(q[i].t-2451545)%146097].y+400*((q[i].t-2451545)/146097);
    }
    for (int i=1;i&lt;=Q;i++){
        printf(&quot;%lld %lld %lld&quot;,ans[i].d,ans[i].m,mabs(ans[i].y));
        if (ans[i].y&lt;0) printf(&quot; BC&quot;);
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>
<h2 id="t2-2">t2</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
#define ull unsigned long long 
using namespace std;
long long n,m,c,k,v,y,t;
ull p,x;
int b[105];
//int x,v,y,p,ans,b[105],t;
signed main(){
	scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;c,&amp;k);
	for(int i = 1; i &lt;= n; i++){
		scanf(&quot;%llu&quot;,&amp;x);
		p |= x;
	}
	for(int i = 1; i &lt;= m; i++){
		scanf(&quot;%lld%lld&quot;,&amp;v,&amp;y);
		b[v] = 1;
	}
	for(int i = 0; i &lt;= k-1; i++ )
		if(((p&gt;&gt;i) &amp; 1) || !b[i]) t++;
	if(t &lt;= 63) printf(&quot;%llu\n&quot;,(1ull &lt;&lt; t) - n);
	else{
		n == 0 ?puts(&quot;18446744073709551616&quot;):printf(&quot;%llu\n&quot;,(((1ull&lt;&lt;63) - 1) | (1ull &lt;&lt; 63)) - (ull)(n-1));
	}
	return 0;
}
</code></pre>
<h2 id="t3-2">t3</h2>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
inline ll read(){
	ll x=0,sign=0; char s=getchar();
	while(s&gt;'9'||s&lt;'0')sign|=s=='-',s=getchar();
	while(s&lt;='9'&amp;&amp;s&gt;='0')x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0',s=getchar();
	return sign?-x:x;
}

const int N=1e5+5;
const int mod=998244353;

int n,m,c,a[N],deg[N],func[N];
int tp[N],pos[N],val[N];
ll mu=1,mul[N],dp[N],add[N];
vector &lt;int&gt; e[N];
queue &lt;int&gt; q;

bool vis[N];
void dfs(int id){
	vis[id]=1,mul[id]=(tp[id]==2?val[id]:1);
	for(int it:e[id]){
		if(!vis[it])dfs(it);
		mul[id]=mul[id]*mul[it]%mod;
	}
}

int main(){
	n=read(); for(int i=1;i&lt;=n;i++)a[i]=read();
	m=read();
	for(int i=1;i&lt;=m;i++){
		tp[i]=read();
		if(tp[i]==1)pos[i]=read(),val[i]=read();
		else if(tp[i]==2)val[i]=read();
		else{
			c=read();
			while(c--){
				int to=read();
				e[i].push_back(to),deg[to]++;
			}
		}
	} c=read();
	for(int i=1;i&lt;=m;i++)if(!vis[i]&amp;&amp;!deg[i])dfs(i);
	for(int i=1;i&lt;=c;i++)func[i]=read();
	for(int i=c,f=func[i];i;i--,f=func[i]){
		if(tp[f]==1)dp[f]=(dp[f]+mu);
		else if(tp[f]==2)mu=mu*val[f]%mod;
		else dp[f]=(dp[f]+mu),mu=mu*mul[f]%mod;
	} for(int i=1;i&lt;=m;i++)if(!deg[i])q.push(i);
	while(!q.empty()){
		int t=q.front(); q.pop();
		if(tp[t]==1)add[pos[t]]=(add[pos[t]]+dp[t]*val[t])%mod;
		ll z=dp[t]; reverse(e[t].begin(),e[t].end());
		for(int p:e[t]){
			deg[p]--; if(!deg[p])q.push(p);
			dp[p]=(dp[p]+z)%mod,z=z*mul[p]%mod;
		}
	} for(int i=1;i&lt;=n;i++)cout&lt;&lt;(a[i]*mu+add[i])%mod&lt;&lt;&quot; &quot;;
	return 0;
}

</code></pre>
<h2 id="t4-2">t4</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;fstream&gt;
#include&lt;cmath&gt;
using namespace std;
#define pii pair&lt;int,int&gt;
#define mp(x,y) make_pair(x,y)
inline int read(){
	char ch=getchar();
	int res=0,f=1;
	for(;ch&lt;'0'||ch&gt;'9';ch=getchar())if(ch=='-')f=-1;
	for(;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())res=(res&lt;&lt;3)+(res&lt;&lt;1)+(ch-'0');
	return res*f;
}
const int MAXN=1e6+5,inf=1e9;
int t,n,a[MAXN];
pii q1[MAXN],q2[MAXN];//q1单调递增，q2单调递减
int l1,r1,l2,r2;//首尾指针
inline pii mx(){//取出最大值且弹出
	if(r1==l1)return q2[l2++];
	else if(r2==l2)return q1[--r1];
	else if(q2[l2]&gt;q1[r1-1])return q2[l2++];
	else return q1[--r1];
}
inline pii mn(){//取出最小值并弹出
	if(l1==r1)return q2[--r2];
	else if(r2==l2)return q1[l1++];
	else if(q2[r2-1]&lt;q1[l1])return q2[--r2];
	else return q1[l1++];
}
inline pii M_min(pii x,pii y){
	return x&lt;y?x:y;
}
inline void solve(){
	l1=r1=l2=r2=0;
	for(int i=1;i&lt;=n;++i)q1[r1++]=mp(a[i],i);//初始化
	int fl=0,cnt=0,alf=0;
	while(1){
		++cnt;//计数器，同时也是死掉的蛇数
		pii x=mn(),y=mx();
		pii z=M_min((l1&lt;r1?q1[l1]:mp(inf,-inf)),(l2&lt;r2?q2[r2-1]:mp(inf,-inf)));//再取出一个最小值
		y.first-=x.first;
		if(y&gt;z||cnt==n-1){//Case2和边界写一起了
			if(fl){
				printf(&quot;%d\n&quot;,n-(fl-(alf&amp;1)));//奇偶性
				return ;
			}
			if(cnt==n-1){
				printf(&quot;1\n&quot;);
				return ;
			}
			q2[r2++]=y;//压入队列
		}
		else {
			alf++;//记录层数
			if(!fl)fl=cnt;	//第一个开始“冒风险”的蛇的之前死了多少
			q2[r2++]=y;//压入队列
		}
	}
}
int main(){
	t=read()-1;
	n=read();
	for(int i=1;i&lt;=n;++i)a[i]=read();
	solve();
	while(t--){
		int k=read();
		for(int i=1,x;i&lt;=k;++i)x=read(),a[x]=read();
		solve();
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文言]]></title>
        <id>https://wyyszl.github.io/post/wen-yan/</id>
        <link href="https://wyyszl.github.io/post/wen-yan/">
        </link>
        <updated>2021-01-19T00:43:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础篇">基础篇</h1>
<h3 id="1-说在前面">1、说在前面</h3>
<p>现在，电脑编程技术日渐新颖。近日，一个文言文语言编程火遍了 github ，这里将会为你讲述如何编写文言文代码。</p>
<h3 id="2-关于wenyan语言的代码与语法">2、关于wenyan语言的代码与语法</h3>
<h4 id="2-1-认识wenyan语言">2-1、认识wenyan语言</h4>
<h5 id="hello-wenyan">Hello wenyan</h5>
<p>咱们都知道，学习一门编程语言是从什么开始的？？<br>
众编程 orz ：当然是 A+B 辣~<br>
哦，不对，学习一门语言应该先从理解这个语言的优缺点啊，基础框架啊等等（回想一下你刚开始学 C++ ，Pascal 的时候）。<br>
但是! wenyan 语言 没有框架！<br>
wenyan 就像 Pascal 一样，定义好变量后就直接开始打主代码了。不会像 C++ 一样还有什么万能头啊，什么 STL 啊，没有这么多,简单易懂（还能提升你的文言文阅读水平）。<br>
现在，我们要开始打主代码，我们先从最基本的 Hello world! 开始吧~<br>
wenyan 的 Helloworld! 的输出是这样的：</p>
<p><code>吾有一言。曰「「Hello world!」」。書之。</code></p>
<p>是不是很生动？很形象？对， wenyan 就是这样！清晰易懂，代码简便......<br>
现在开始介绍 wenyan 的基本语法:</p>
<h3 id="2-2-基本语法">2-2、基本语法</h3>
<h4 id="2-2-1-定义变量">2-2-1、定义变量</h4>
<p>毕竟都说是文言文编程了，肯定不能出现英文字母和数字的嘛~</p>
<p><strong>wenyan vs C++</strong></p>
<pre><code>吾有一數。曰六。名之曰「甲」。	int a（a就是甲）=6;
有數六。名之曰「蒟蒻」。	int juruo=6;
吾有一言。曰「「噫吁戲」」。名之曰「乙」。	string b（s就是乙）=alas!
</code></pre>
<h4 id="2-2-2-ture和false">2-2-2、ture和false</h4>
<p>true/false 分别对应 wenyan 语言中的陽/陰（繁体的阳/阴），类型就是“爻”（卦符的基本符号）：</p>
<p><strong>wenyan vs C++</strong></p>
<pre><code>吾有一爻。曰陽。名之曰「丙」。	bool c=true;
吾有一爻。曰陰。名之曰「丁」。	bool d=false;
</code></pre>
<h4 id="2-2-3-if判断">2-2-3、if判断</h4>
<p>作为一个编程语言怎么少了 if 判断呢？</p>
<p><strong>wenyan vs C++</strong></p>
<pre><code>若三不大於五者。吾有一言。曰「「OK」」。書之。。若非。乃得「「NO」」也。	if(3&lt;=5) cout&lt;&lt;&quot;OK&quot;; else cout&lt;&lt;&quot;NO&quot;;
</code></pre>
<h4 id="2-2-4-运算符">2-2-4、运算符</h4>
<p>加减乘除一应俱全，连逻辑运算符都有!</p>
<p><strong>wenyan vs C++</strong></p>
<pre><code>加一以一。	1+1
除七以三。所餘幾何。	7%3
減六六六六以六六六。名之曰「甲」。	int a=6666-666;
</code></pre>
<h4 id="2-2-5-容器类型">2-2-5 容器类型</h4>
<p>容器类型也支持，而且注意一下，首个下标是从一开始的。</p>
<p><strong>wenyan vs C++</strong></p>
<pre><code>吾有一列。名之曰「数组」。充「数组」以四。以二。	int shuzu[]={4,2};
夫「寶劍」之長。	sword.size;
夫「蒟蒻」之一。	juruo[1];
夫「中国」之「「名」」。	China[&quot;name&quot;]
</code></pre>
<h4 id="2-2-6-进阶语法">2-2-6 进阶语法</h4>
<p>一些 wenyan 的进阶语法。。。。。。</p>
<p><strong>wenyan vs	JavaScript</strong></p>
<pre><code>吾有一術。名之曰「吸星大法」。是術曰。⋯⋯是謂「吸星大法」之術也。	function f(){...}
吾有一術。名之曰「六脈神劍」。欲行是術。必先得六數。曰「甲」。曰「乙」。曰「丙」。曰「丁」。曰「戊」。曰「己」乃行是術曰。⋯⋯是謂「六脈神劍」之術也。	function f(a,b,c,d,e,f){...}
吾有一術。名之曰「翻倍」。欲行是術。必先得一數。曰「甲」。乃行是術曰。乘「甲」以二。名之曰「乙」。乃得「乙」。是謂「翻倍」之術也。	function double(a){var b = a * 2; return b;}
施「翻倍」於「蒟蒻」。	double(juruo);
吾有一數。曰五。書之。	console.log(5);
</code></pre>
<h4 id="2-2-7-循环">2-2-7 循环</h4>
<p>就是那些 for ， while 循环之类的。（注意！ 云云 为 wenyan 语言循环的后面必加的东西！）</p>
<p><strong>wenyan vs C++</strong></p>
<pre><code>為是百遍。⋯⋯ 云云。	for(int i=1;i&lt;=100;i++) ......
恆為是。⋯⋯ 云云。	while(true) ......
乃止。	break
</code></pre>
<p>目前就这些了......</p>
<h3 id="3-编写wenyan语言程序运行">3、编写wenyan语言程序运行</h3>
<p>本人是用洛谷 IDEIDE 进行运行的，当然还有一种网站也可以实现 wenyan 语言的编译运行，还可以实现 wenyan 转 JavaScript 和 Python 的功能！（虽然我都不会......）<br>
这个网站就是：<a href="https://wy-lang.org/ide?example=beer">hhh</a> ！<br>
这里面有不少好康和好玩的东西，你也可以在这里面编译。<br>
而且项目文件还有个脚本src/render.js，它可以把程序渲染成古代书籍的样子。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/ioswoq7n.png" alt="" loading="lazy"></figure>
<h3 id="4-关于wenyan语言编程">4、关于wenyan语言编程</h3>
<p>夫唐、虞之世，結繩而足治，屈指而足算。是時豈料百代之後，計算機械之巧，精於公輸之木鳶，善於武侯之流馬；程式語言之多，繁若《天官》之星宿，奇勝《山經》之走獸。鼠、蟹、鑽、魚，或以速稱。蛇、象、駱、犀，各爭文采。方知鬼之所以夜哭，天之所以雨粟。然以文言編程者 ，似所未有。此非文脈之所以傳，文心之所以保。嗟予小子，遂有斯志。然則數寸之烏絲猶覆於頭，萬卷之素書未破於手；一身長羁于远邦，兩耳久旷于雅言。然夫文章者吾之所宿好，程式者偶承時人之謬譽。故希孟不慚年少，莊生不望無涯。乃作斯言。未能嘔瀝長吉之心血，亦庶幾免於義山之流沫。既成之後，復學干將鑄劍而自飼，越王嚐糞而當先。自謂偶追《十書》之筆意，但恨少八家之淋漓。此子山所謂士衡抚掌而甘心，平子見陋而固宜。然則雖實覆甕之質，尚存斧正之望；雖乏呂相之金，易字之渴蓋同。此亦開源之大義，吾輩之所以勉勵也。一笑。 ----Huang Lingdong（wenyan语言作者）</p>
<p>Huang Lingdong，来自卡耐基梅隆大学，如今大四，明年即将毕业。高中则毕业自上海世界外国语中学。<br>
就是这个小伙子，做出了这个风靡 github 的 wenyan 语言！</p>
<h3 id="5-写在最后">5、写在最后</h3>
<p>到最后，不知道大家看懂没（反正我是看懂了）。<br>
好了，我的 wenyan 语言就讲到这里了，谢谢观看的各位 orz！<br>
tql</p>
<h1 id="提升篇">提升篇</h1>
<h3 id="part-1-输入输出进阶">Part 1 输入输出进阶</h3>
<p>输出和输入是一切语言的基本操作。文言的输出简洁，输入则稍微繁琐。</p>
<h4 id="输出">输出</h4>
<p>输出语句的标志：書之。</p>
<p><code>吾有一數。...書之。</code>：输出数字，阿拉伯形式。</p>
<p>数字的范围是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mo>−</mo><msup><mn>2</mn><mn>256</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>256</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">[-2^{256},2^{256})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">5</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">5</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>其中...中，表示常量使用中文表示，也可使用变量形式。</p>
<p>如：<code>吾有一數。曰三十七。書之。</code>输出 37。</p>
<p><code>吾有一言。...書之。</code>：输出字符串。</p>
<p>字符串表示为<code>「「...」」</code>形式。（注意有二层括号）</p>
<p>如：<code>吾有一言。曰「「字符串」」。書之。</code>输出字符串。</p>
<p>以上每次“书之”语句的输出各占一行。为了在一行内输出多个数字，可以使用以下语句：</p>
<p><code>吾有三數。曰三千二百四十一。曰五百五十。曰一千零五。書之。</code></p>
<p>输出<code>3241 550 1005</code>。</p>
<h4 id="输入">输入</h4>
<p>输入由于还未设专门函数，使用Javascript函数完成。</p>
<p>先看一下A+B Problem给的输入：</p>
<pre><code>施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「數據」。
施「(buf =&gt; buf.toString().trim())」於「數據」。昔之「數據」者。今其是矣。
施「(s =&gt; s.split(' '))」於「數據」。昔之「數據」者。今其是矣。
注曰。「「文言尚菜，無對象之操作，故需 JavaScript 之语法」」。

夫「數據」之一。取一以施「parseInt」。名之曰「甲」。
夫「數據」之二。取一以施「parseInt」。名之曰「乙」。
</code></pre>
<p>其中注曰之前的函数不用管(split除外)。</p>
<p>讲解：<code>「(s =&gt; s.split(' '))」</code>将数据拆分，以某个符号为界限（注意这个符号不在函数结果之内）。</p>
<p><code>「parseInt」</code>将字符串转换为数字。</p>
<p>一些语法会在后提到。</p>
<p>先给一个得到一行数字的函数。</p>
<pre><code>吾有一術。名之曰「输入」。是術曰。
    施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「入」。
    施「(buf =&gt; buf.toString().trim())」於「入」。昔之「入」者。今其是矣。
    施「(s =&gt; s.split('\n'))」於「入」。昔之「入」者。今其是矣。
    乃得「入」也。
是謂「输入」之術也。

吾有一數。曰零。名之曰「其行」。
施「输入」。名之曰「初始输入」。

吾有一術。名之曰「得数」。是術曰。
    吾有一列。名之曰「其数」。
    加「其行」以一。昔之「其行」者。今其是矣。
    夫「初始输入」之「其行」。名之曰「此行」。
    施「(s =&gt; s.split(' '))」於「此行」。昔之「此行」者。今其是矣。
    夫「此行」之長。名之曰「长」。
    吾有一數。曰零。名之曰「下标」。
    為是「长」遍。
        加「下标」以一。昔之「下标」者。今其是矣。
        夫「此行」之「下标」。名之曰「此数」。
        施「parseInt」於「此数」。昔之「此数」者。今其是矣。
        銜「其数」以「此数」。昔之「其数」者。今其是矣。
    云云。
    乃得「其数」也。
是謂「得数」之術也。
</code></pre>
<p>如果看过浅谈，应该不难理解：将初始输入用换行符拆分为各行；使用一个变量表示目前所在的行；每行要用时用空格拆分成各个小字符串；将小字符串转为数字后装入列表返回。</p>
<h3 id="part-2-变量">Part 2 变量</h3>
<h4 id="声明">声明</h4>
<p><code>吾有一數。曰一。名之曰「数」</code>。声明数字。相当于int a=...</p>
<p><code>吾有一言。曰「「字符串」」。名之曰「文」。</code>声明字符串。</p>
<p><code>吾有一爻。曰陽。名之曰「布尔型」。</code>声明布尔型变量。</p>
<p>（布尔值表示：<code>陽</code>为真，<code>陰</code>为假）</p>
<p><code>吾有一元。...名之曰「自动类型」。</code>声明的变量自动判断类型，相当于C++11的<code>auto</code>。</p>
<p>也可以用这个形式：<code>有數一。名之曰「数」。</code></p>
<p>多个变量同时声明：<code>吾有三數。曰一。曰二。曰三。名之曰「数甲」曰「数乙」曰「数丙」。</code></p>
<h4 id="自动变量">自动变量</h4>
<p><code>其</code>：最近的算出的答案。</p>
<p>使用<br>
用括号<code>「」</code>括变量名。如<code>「变量」</code>。</p>
<p>特别地，使用自动变量其时不带括号。</p>
<h4 id="赋值">赋值</h4>
<p><code>...昔之「变量」者。今其是矣。</code>赋前面最近所算出的答案。</p>
<p><code>昔之「变量」者。今...是矣。</code>赋为此语句给出的值。相当于<code>var=...</code></p>
<h3 id="part-3-运算">Part 3 运算</h3>
<h4 id="数字运算">数字运算</h4>
<p><code>加...以...。</code>对应<code>+</code>运算。</p>
<p><code>减...以...。</code>对应<code>-</code>运算。</p>
<p><code>乘...以...。</code>对应<code>*</code>运算。</p>
<p><code>除...以...。</code>对应<code>/</code>运算。注意此运算保留小数。</p>
<p><code>除...以...。</code>所餘幾何。对应<code>%</code>（取模）运算。</p>
<h4 id="大小关系判断">大小关系判断</h4>
<p><code>...大於...</code>对应<code>&gt;</code>运算。</p>
<p><code>...不大於...</code>对应<code>&lt;=</code>运算。</p>
<p><code>...小於...</code>对应<code>&lt;</code>运算。</p>
<p><code>...不小於...</code>对应<code>&gt;=</code>运算。</p>
<p><code>...等於...</code>对应<code>==</code>运算。</p>
<h4 id="布尔值运算">布尔值运算</h4>
<p><code>夫...中有陽乎。</code>对应<code>||</code>（或）运算。</p>
<p><code>夫...中無陰乎。</code>对应<code>&amp;&amp;</code>（与）运算。</p>
<p>如：<code>夫「布尔值甲」「布尔值乙」中有陽乎。</code></p>
<h3 id="part-4-分支与循环">Part 4 分支与循环</h3>
<h4 id="分支语句">分支语句</h4>
<pre><code>若...(条件)者。
    ...(真时代码块)
若非。（等同else，可选）
    ...（假时代码块，可选）
云云。（if结束）
</code></pre>
<p>如：</p>
<pre><code>若三不大於五者。
    吾有一言。曰「「想当然」」。書之。
若非。
    吾有一言。曰「「电脑出锅」」。書之。
云云。
</code></pre>
<p>相当于</p>
<pre><code>if (3&lt;=5) printf(&quot;of course&quot;);
else printf(&quot;bad computer&quot;);
</code></pre>
<p><code>或若...</code>：相当于<code>else if</code>语句。</p>
<p><code>若其然者/若其不然者</code>：当自动变量<code>其</code>不为零/为零时执行语句。</p>
<h4 id="循环语句">循环语句</h4>
<p><code>為是...（循环次数）遍。</code>声明一个执行特定次的循环开始。</p>
<p>相当于<code>for(i=0;i&lt;n;++i)</code></p>
<p><code>恆為是。</code>声明一个死循环的开始。可以用<code>乃止。</code>语句结束。</p>
<p>相当于<code>for(;;)</code></p>
<p><code>云云。</code>声明循环部分结束。（和分支语句一样）</p>
<p><code>乃止。</code>跳出最内的一个循环，相当于<code>break</code>语句。</p>
<p><code>乃止是遍。</code>返回到循环开始，相当于<code>continue</code>语句。</p>
<h3 id="part-5-数组">Part 5 数组</h3>
<h4 id="声明-2">声明</h4>
<p><code>吾有一列。名之曰「数组」。</code></p>
<p>相当于<code>[类型未知] array={};</code></p>
<p>声明带赋值：<code>吾有一列。名之曰「数组」。充「数组」以零。以一。</code></p>
<p>相当于<code>[类型未知] array={0,1};</code></p>
<h4 id="调用">调用</h4>
<p>查询数组内容：<code>夫「数组」之...(下标)</code>返回容器特定下标的值。下标从一开始。如<code>夫「数组」之一，夫「容器」之「「字符串」」。</code></p>
<p>数组内容更改：<code>昔之「数组」之...（下标）者。今...是矣。</code></p>
<p>查询数组大小：<code>夫「数组」之長。</code></p>
<p>相当于<code>list.size()</code></p>
<p>连接不同数组或数组与元素连接：<code>銜「数组」以...(连接目标)。</code>此函数将结果数组返回，不改变原有数组。</p>
<p>声明遍历数组内容的循环开始：<code>凡「数组」中之「变量」。</code>（也是<code>云云。</code>结束）</p>
<p>将数加在数组后面：<code>充「数组」以一。 充「数组」以一。以二。。</code></p>
<p>相当于<code>array.push(1); array.push(1);array.push(2);</code></p>
<h3 id="part-6-函数">Part 6 函数</h3>
<h4 id="声明-3">声明</h4>
<p>函数声明开始：<code>吾有一術。名之曰「函数」。是術曰。</code></p>
<p>相当于<code>[返回值类型未知] function()</code></p>
<p>带参数：</p>
<p><code>吾有一術。名之曰「函数」。欲行是術。必先得一數。曰「参数」。是術曰。</code></p>
<p>相当于<code>[返回值类型未知] function(int var_a)</code></p>
<p><code>吾有一術。名之曰「函数」。欲行是術。必先得...(参数个数)數。曰「参数一」。曰「参数二」。...(声明各种参数)是術曰。</code></p>
<p>注：这里的参数类型也可以是字符串（<code>言</code>）、布尔值等。</p>
<p>函数结束声明：<code>是謂「函数」之術也。</code></p>
<p>格式：</p>
<pre><code>吾有一術。名之曰「函数」。...（参数声明，可选）是術曰。
    ...（函数内容）
是謂「函数」之術也。
</code></pre>
<p>比如这就是一个求线段树右儿子的函数（注意参数不是以指针形式传入的）</p>
<pre><code>吾有一術。名之曰「其右」。欲行是術。必先得一數。曰「节点」。是術曰。
    乘「节点」以二。昔之「节点」者。今其是矣。
    加「节点」以一。昔之「节点」者。今其是矣。
    乃得「节点」也。
是謂「其右」之術也。
</code></pre>
<p>返回结果：<code>乃得...（函数返回值）也。</code>注意编译时它自带右括号，因此在分支或循环语句末尾时要处理（把<code>云云。</code>删去）。</p>
<p>当返回不带返回值时，使用<code>乃歸空無。</code>语句。</p>
<p>调用<br>
函数的调用非常简洁。<code>施「函数」。</code>（无参）<br>
<code>施「函数」於...。於...（代入各参数）</code>（有参）</p>
<p>尽管函数声明时规定了参数个数，但是调用时参数个数可以少于规定个数。这将返回一个函数，表现为原函数前面一些参数固定的版本。</p>
<p>举例：</p>
<pre><code>吾有一術。名之曰「修改」。欲行是術。必先得六數。曰「节点」。曰「左」。曰「右」。曰「改左」。曰「改右」。曰「增值」。是術曰。[1]
    ...
是謂「修改」之術也。

...
施「修改」於一。於一。於「树长」。名之曰「简易修改」。[2]
...
施「简易修改」於「改左」。於「改右」。於「增值」。...[3]
</code></pre>
<p>说明：上面代码中[1]处声明了线段树的修改函数，其中有六个参数。考虑到主函数中调用此函数前三个参数是固定的，于是在[2]处通过不完全参数定义了新函数<code>「简易修改」</code>，调用简易版函数时（[3]）只用带入原函数的后三个参数就可以了。</p>
<p>附加：<a href="https://github.com/wenyan-lang/wenyan/blob/master/documentation/Nested-Function-Calls.md">函数嵌套的一种简易方法</a></p>
<h3 id="part-7-结构体">Part 7 结构体</h3>
<p>声明：<code>吾有一物。名之曰「结构体」。</code></p>
<p>带内容声明：</p>
<pre><code>吾有一物。名之曰「结构体」。其物如是。
    物之「「数」」者。數曰一。
    物之「「文」」者。言曰「「字符串」」。
    ...（声明结构体各个内容）
是謂「结构体」之物也。
</code></pre>
<p>用法与数组类似。</p>
<h3 id="part-8-标准库">Part 8 标准库</h3>
<p>调用标准库前声明：<code>吾嘗觀「「...（库名）」」之書。方悟「...（调用函数名）」之義。</code>声明后可以像正常函数一样调用。</p>
<p>也可以一次声明多个：<code>吾嘗觀「「算經」」之書。方悟「正弦」「餘弦」之義。</code></p>
<p>调用特定文件的语法举例：<code>吾嘗觀「「codes」」中「「luogu」」中「「p1001」」之書。</code>调用codes/luogu/p1001。</p>
<p><a href="https://github.com/wenyan-lang/wenyan/blob/master/documentation/Standard-Lib.md">标准库所有函数</a></p>
<p><a href="https://github.com/wenyan-lang/wenyan/blob/master/documentation/Importing.md">官方说明·导入</a></p>
<p><code>算經</code>库<br>
算经库提供了一些数学函数。</p>
<p>部分标准库函数：</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/h8mq58pi.png" alt="" loading="lazy"></figure>
<p><code>列經</code>库<br>
提供了数组操作。这里只提供部分常用操作。</p>
<p>函数	对应</p>
<p><code>遍施</code>	对数组内所有数<code>x</code>执行    <code>x=function(x)</code>后返回<br>
<code>排序</code>	<code>sort()</code><br>
<code>倒序</code>	<code>reverse()</code><br>
<code>曆法</code>库<br>
历法库提供时间操作。</p>
<p><code>今何紀元時 言今之日時 今年何年 今年何年號 今年何干支 今時何時 今時何小時 今刻何刻 今分何分 今秒何秒</code> 等函数。很大一部分都是古人算法，现在不常用</p>
<p>调用<code>言今之日時</code>函数可以直接输出现在的时间。</p>
<p>Part 9 注释</p>
<pre><code>注曰。「「注释内容」」。

批曰。「「注释内容」」。

疏曰。「「注释内容」」。
</code></pre>
<p>它们相当于其他语言中被<code>/*</code>,<code>*/</code>括起的注释。</p>
<h3 id="part-10-杂项">Part 10 杂项</h3>
<p>连接两个字符串：<code>加「字符串甲」以「字符串乙」。</code>相当于<code>strcat(str_a,str_b);</code></p>
<p>宏定义： <code>或云「「宏名称」」。 蓋謂「「替换内容」」。</code></p>
<p><a href="https://github.com/wenyan-lang/wenyan/blob/master/documentation/Macros.md">官方说明</a></p>
<p>比如：<code>或云「「書「甲」焉」」。 蓋謂「「吾有一言。曰「甲」。書之」」。</code></p>
<p>相当于<code>#define output(str) cout&lt;&lt;str</code></p>
<p>异常处理（<code>try-catch</code>语句）</p>
<p><a href="https://github.com/wenyan-lang/wenyan/blob/master/documentation/Try-Catch.md">官方说明</a></p>
<p><a href="https://ide.wy-lang.org/?example=try">示例</a></p>
<p><code>try</code>语句：<code>姑妄行此。</code>表示需检测异常语句段开始。</p>
<p><code>throw</code>语句：<code>嗚呼。「「异常内容」」之禍。</code>表示检测到异常，跳到<code>catch</code>段处理。相当于<code>throw &quot;error&quot;;</code></p>
<p><code>catch</code>语句：如事不諧。表示检测到异常后执行的代码块开始。</p>
<p>在<code>catch</code>语句内判断异常内容的特殊<code>if</code>语句：<code>豈「「异常内容」」之禍歟。</code></p>
<p>上述特殊<code>if</code>语句对应的<code>else</code>：<code>不知何禍歟。</code></p>
<p>上述<code>else</code>获得具体异常信息：<code>不知何禍歟。名之曰「异常信息」。</code></p>
<p><code>catch</code>语句结束：<code>乃作罷。</code></p>
<p>通俗点，就是先执行<code>try</code>到<code>catch</code>之间的代码，这一段代码中若满足一些条件使得其中的<code>throw</code>语句被执行了，那么忽略之后所有<code>try</code>到<code>catch</code>间的代码，执行<code>catch</code>段代码。如果没有，则<code>catch</code>段代码不被执行。</p>
<h4 id="文言官方文件附带">文言官方文件附带</h4>
<p><a href="http://wenyan-lang.lingdong.works/ide.html">官方IDE</a></p>
<p>把代码渲染成古文样式（浅谈已说）</p>
<p>将输出的数转为汉字的功能</p>
<p>一些样例文件（官方IDE中可以找到）</p>
<h3 id="part-11-例子">Part 11 例子</h3>
<h4 id="ab">A+B</h4>
<pre><code>施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「數據」。
施「(buf =&gt; buf.toString().trim())」於「數據」。昔之「數據」者。今其是矣。
施「(s =&gt; s.split(' '))」於「數據」。昔之「數據」者。今其是矣。

夫「數據」之一。取一以施「parseInt」。名之曰「甲」。
夫「數據」之二。取一以施「parseInt」。名之曰「乙」。

加「甲」以「乙」。書之。
</code></pre>
<h4 id="输入模板">输入模板</h4>
<pre><code>吾有一術。名之曰「函数」。欲行是術。必先得二數。曰「甲」。曰「乙」。是術曰。
	吾有一列。名之曰「列」。
   	為是「甲」遍。
   		銜「列」以「乙」。昔之「列」者。今其是矣。
   	云云。
    吾有一言。曰「「黄河流水鸣溅溅」」。書之。
    夫「列」之長。書之。
    乃得「乙」也。
是謂「函数」之術也。

施「函数」於四。於六。書之。
</code></pre>
<h4 id="大常数线段树">大常数线段树</h4>
<pre><code>吾嘗觀「「算經」」之書。方悟「取底」之義。

吾有一術。名之曰「输入」。是術曰。
    施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「入」。
    施「(buf =&gt; buf.toString().trim())」於「入」。昔之「入」者。今其是矣。
    施「(s =&gt; s.split('\n'))」於「入」。昔之「入」者。今其是矣。
    乃得「入」也。
是謂「输入」之術也。

吾有一數。曰零。名之曰「其行」。
施「输入」。名之曰「初始输入」。

吾有一術。名之曰「得数」。是術曰。
    吾有一列。名之曰「其数」。
    加「其行」以一。昔之「其行」者。今其是矣。
    夫「初始输入」之「其行」。名之曰「此行」。
    施「(s =&gt; s.split(' '))」於「此行」。昔之「此行」者。今其是矣。
    夫「此行」之長。名之曰「长」。
    吾有一數。曰零。名之曰「下标」。
    為是「长」遍。
        加「下标」以一。昔之「下标」者。今其是矣。
        夫「此行」之「下标」。名之曰「此数」。
        施「parseInt」於「此数」。昔之「此数」者。今其是矣。
        充「其数」以「此数」。
    云云。
    乃得「其数」也。
是謂「得数」之術也。

吾有一列。名之曰「权」。
吾有一列。名之曰「懒标记」。
吾有一列。名之曰「原值」。

吾有一術。名之曰「其左」。欲行是術。必先得一數。曰「节点」。是術曰。
    乘「节点」以二。昔之「节点」者。今其是矣。
    乃得「节点」也。
是謂「其左」之術也。

吾有一術。名之曰「其右」。欲行是術。必先得一數。曰「节点」。是術曰。
    乘「节点」以二。昔之「节点」者。今其是矣。
    加「节点」以一。昔之「节点」者。今其是矣。
    乃得「节点」也。
是謂「其右」之術也。

吾有一術。名之曰「上传」。欲行是術。必先得一數。曰「节点」。是術曰。
    施「其左」於「节点」。名之曰「左子」。
    施「其右」於「节点」。名之曰「右子」。
    夫「权」之「左子」。名之曰「左权」。
    夫「权」之「右子」。名之曰「右权」。
    加「左权」以「右权」。昔之「权」之「节点」者。今其是矣。
是謂「上传」之術也。

吾有一術。名之曰「打标记」。欲行是術。必先得四數。曰「节点」。曰「左」。曰「右」。曰「标记」。是術曰。
    夫「懒标记」之「节点」。名之曰「原标」。
    加「原标」以「标记」。昔之「懒标记」之「节点」者。今其是矣。
    減「右」以「左」。名之曰「长」。
    加「长」以一。昔之「长」者。今其是矣。
    乘「长」以「标记」。名之曰「增值」。
    夫「权」之「节点」。名之曰「原权」。
    加「原权」以「增值」。昔之「权」之「节点」者。今其是矣。
是謂「打标记」之術也。

吾有一術。名之曰「其中」。欲行是術。必先得二數。曰「左」。曰「右」。是術曰。
    加「左」以「右」。名之曰「结果」。
    除「结果」以二。昔之「结果」者。今其是矣。
    施「取底」於「结果」。昔之「结果」者。今其是矣。
    乃得「结果」也。
是謂「其中」之術也。

吾有一術。名之曰「下传」。欲行是術。必先得三數。曰「节点」。曰「左」。曰「右」。是術曰。
    夫「懒标记」之「节点」。名之曰「其标」。
    若「其标」不等於零者。
        若「左」小於「右」者。
            施「其中」於「左」。於「右」。名之曰「中」。
            加「中」以一。名之曰「右始」。
            施「其左」於「节点」。名之曰「左子」。
            施「其右」於「节点」。名之曰「右子」。
            施「打标记」於「左子」。於「左」。於「中」。於「其标」。
            施「打标记」於「右子」。於「右始」。於「右」。於「其标」。
        云云。
        昔之「懒标记」之「节点」者。今零是矣。
    云云。
是謂「下传」之術也。

吾有一術。名之曰「建树」。欲行是術。必先得三數。曰「节点」。曰「左」。曰「右」。是術曰。
    若「左」等於「右」者。
        夫「原值」之「左」。昔之「权」之「节点」者。今其是矣。
    若非。
        施「其中」於「左」。於「右」。名之曰「中」。
        加「中」以一。名之曰「右始」。
        施「其左」於「节点」。名之曰「左子」。
        施「其右」於「节点」。名之曰「右子」。
        施「建树」於「左子」。於「左」。於「中」。
        施「建树」於「右子」。於「右始」。於「右」。
        施「上传」於「节点」。
    云云。
是謂「建树」之術也。

吾有一術。名之曰「包含」。欲行是術。必先得四數。曰「左」。曰「右」。曰「改左」。曰「改右」。是術曰。
    若「左」小於「改左」者。乃得陰也。
    若「右」大於「改右」者。乃得陰也。
    乃得陽也。
是謂「包含」之術也。

吾有一術。名之曰「修改」。欲行是術。必先得六數。曰「节点」。曰「左」。曰「右」。曰「改左」。曰「改右」。曰「增值」。是術曰。
    施「下传」於「节点」。於「左」。於「右」。
    施「包含」於「左」。於「右」。於「改左」。於「改右」。名之曰「是否包含」。
    若「是否包含」等於陽者。
        施「打标记」於「节点」。於「左」。於「右」。於「增值」。
    云云。
    若「是否包含」等於陰者。
        施「其中」於「左」。於「右」。名之曰「中」。
        加「中」以一。名之曰「右始」。
        施「其左」於「节点」。名之曰「左子」。
        施「其右」於「节点」。名之曰「右子」。
        若「改左」不大於「中」者。
            施「修改」於「左子」。於「左」。於「中」。於「改左」。於「改右」。於「增值」。
        云云。
        若「改右」大於「中」者。
            施「修改」於「右子」。於「右始」。於「右」。於「改左」。於「改右」。於「增值」。
        云云。
        施「上传」於「节点」。
    云云。
是謂「修改」之術也。

吾有一術。名之曰「查询」。欲行是術。必先得五數。曰「节点」。曰「左」。曰「右」。曰「改左」。曰「改右」。是術曰。
    施「下传」於「节点」。於「左」。於「右」。
    施「包含」於「左」。於「右」。於「改左」。於「改右」。名之曰「是否包含」。
    吾有一數。曰零。名之曰「果」。
    若「是否包含」等於陽者。
        夫「权」之「节点」。昔之「果」者。今其是矣。
    云云。
    若「是否包含」等於陰者。
        施「其中」於「左」。於「右」。名之曰「中」。
        加「中」以一。名之曰「右始」。
        施「其左」於「节点」。名之曰「左子」。
        施「其右」於「节点」。名之曰「右子」。
        若「改左」不大於「中」者。
            施「查询」於「左子」。於「左」。於「中」。於「改左」。於「改右」。名之曰「左权」。
            加「果」以「左权」。昔之「果」者。今其是矣。
        云云。
        若「改右」大於「中」者。
            施「查询」於「右子」。於「右始」。於「右」。於「改左」。於「改右」。名之曰「右权」。
            加「果」以「右权」。昔之「果」者。今其是矣。
        云云。
    云云。
    乃得「果」也。
是謂「查询」之術也。

施「得数」。名之曰「其数」。
夫「其数」之一。名之曰「数量」。
夫「其数」之二。名之曰「操作数」。
乘「数量」以四。名之曰「树长」。
為是「树长」遍。
    充「权」以零。
    充「懒标记」以零。
云云。
施「得数」。昔之「其数」者。今其是矣。
吾有一數。曰零。名之曰「下标」。
為是「数量」遍。
    加「下标」以一。昔之「下标」者。今其是矣。
    夫「其数」之「下标」。名之曰「此数」。
    充「原值」以「此数」。
云云。
施「建树」於一。於一。於「数量」。
為是「操作数」遍。
    施「得数」。昔之「其数」者。今其是矣。
    夫「其数」之一。名之曰「操作」。
    夫「其数」之二。名之曰「改左」。
    夫「其数」之三。名之曰「改右」。
    若「操作」等於一者。
        夫「其数」之四。名之曰「增值」。
        施「修改」於一。於一。於「数量」。於「改左」。於「改右」。於「增值」。
    云云。
    若「操作」等於二者。
        施「查询」於一。於一。於「数量」。於「改左」。於「改右」。名之曰「果」。
        加「果」以零。昔之「果」者。今其是矣。
        吾有一數。曰「果」。書之。
    云云。
云云。
</code></pre>
<h4 id="函数-数组综合">函数、数组综合</h4>
<pre><code>吾有一術。名之曰「函数」。欲行是術。必先得二數。曰「甲」。曰「乙」。是術曰。
	吾有一列。名之曰「列」。
   	為是「甲」遍。
   		銜「列」以「乙」。昔之「列」者。今其是矣。
   	云云。
    吾有一言。曰「「黄河流水鸣溅溅」」。書之。
    夫「列」之長。書之。
    乃得「乙」也。
是謂「函数」之術也。

施「函数」於四。於六。書之。
</code></pre>
<h4 id="洛谷p5834-moobuzz">洛谷P5834 MooBuzz</h4>
<pre><code>注曰。「「注曰语句是程序中的注释。」」。
注曰。「「注释中说明的语句是简体字。实际编程中需要使用繁体。」」。

吾嘗觀「「算經」」之書。方悟「取底」之義。
注曰。「「吾尝观...之义语句导入库中函数。」」。

吾有一術。名之曰「判断合法」。欲行是術。必先得一數。曰「甲」。是術曰。
注曰。「「判断是否会被报出。吾有一术名之曰语句声明函数」」。
注曰。「「欲行其术必先得...曰语句声明参数。无参时可省略。曰可以有多个。」」。
注曰。「「是术曰语句声明函数开始」」。
    除「甲」以三。所餘幾何。名之曰「除三之余」。
    若「除三之余」等於零者。乃得陰也。
    注曰。「「若...乃语句表示满足某个条件时的返回值。」」。
    注曰。「「三的倍数不会被报出」」。
    除「甲」以五。所餘幾何。名之曰「除五之余」。
    若「除五之余」等於零者。乃得陰也。
    注曰。「「五的倍数不会被报出」」。
    乃得陽也。
    注曰。「「如果不是三的倍数也不是五的倍数，它就会被报出」」。
    注曰。「「返回布尔值。阳表示真，阴表示假。」」。
是謂「判断合法」之術也。
注曰。「「是谓...之术也语句声明函数结束。」」。

施「require('fs').readFileSync」於「「/dev/stdin」」。名之曰「初始输入」。
施「(buf =&gt; buf.toString().trim())」於「初始输入」。昔之「初始输入」者。今其是矣。
施「parseInt」於「初始输入」。名之曰「甲」。
注曰。「「输入部分。使用Javascript的语法。」」。
注曰。「「parseInt函数将字符串转换为数字」」。
除「甲」以八。名之曰「周期数」。
注曰。「「计算此数之前的完整周期次数。」」。
注曰。「「加/乘/除...以语句进行运算。」」。
注曰。「「名之曰语句声明变量。其值在前面语句提到。」」。
施「取底」於「周期数」。昔之「周期数」者。今其是矣。
注曰。「「此语言除法不会向下取整，需要使用函数。」」。
注曰。「「施...于语句执行函数。于传入参数，可以有多个。」」。
注曰。「「昔之..者斤其是矣语句将变量重新复值。其值在前面语句提到。」」。
乘「周期数」以十五。名之曰「结果」。
加「结果」以负一。昔之「结果」者。今其是矣。
注曰。「「现在的结果是上文中15k-1的值。」」。
除「甲」以八。所餘幾何。名之曰「剩余」。
注曰。「「往后剩余要找的数字数量即为N除8的余数。」」。
注曰。「「除...以...所余几何语句计算余数。」」。
恆為是。
注曰。「「恒为是语句表明一个死循环。」」。
    若「剩余」小於一者。乃止。云云。
    注曰。「「现在已经是目标，退出循环并输出它」」。
    注曰。「「乃止语句表明退出循环，相当于break。」」。
    注曰。「「若...云云语句表明若满足条件会执行的语句。相当于if。」」。
    加「结果」以一。昔之「结果」者。今其是矣。
    施「判断合法」於「结果」。名之曰「是否合法」。
    注曰。「「将当前数增加一，然后检查是否会被报出」」。
    若「是否合法」等於陽者。
        加「剩余」以负一。昔之「剩余」者。今其是矣。
        注曰。「「次数会被报出。找的数的剩余数量减一。」」。
    云云。
云云。
注曰。「「此处的云云语句说明循环结束。」」。
加「结果」以零。書之。
注曰。「「将最终的结果输出。」」。
注曰。「「书之语句进行输出。调用此语句将在最后额外输出一个换行符。」」。
</code></pre>
<p>c++\</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;
typedef long long ll;

bool check(ll x) {
    if (x%3==0) return false;
    if (x%5==0) return false;
    return true;
}
int main() {
    ll k; scanf(&quot;%lld&quot;,&amp;k);
    ll res=15LL*(k/8)-1; k&amp;=7;
    while (k) {
        if (check(++res)) --k;
    }
    printf(&quot;%d&quot;, res);
    return 0;
}
</code></pre>
<h2 id="总结">总结</h2>
<p>文言是一种广受欢迎的新生编程语言，优缺点总结如下：</p>
<h3 id="优点">优点</h3>
<p>对于中国人来说，代码可以作为注释，容易理解程序作用</p>
<p>弘扬中华传统文化</p>
<h3 id="缺点">缺点</h3>
<p>不方便输入，如一些繁体字、特殊括号等</p>
<p>一些函数如输入还未完善</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[csp5020]]></title>
        <id>https://wyyszl.github.io/post/csp5020/</id>
        <link href="https://wyyszl.github.io/post/csp5020/">
        </link>
        <updated>2021-01-16T12:14:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="赛前琐事">赛前琐事：</h1>
<h3 id="day-28">day -28：</h3>
<p>whk 考试，全线炸掉，扎到 200 名。</p>
<h3 id="day-26">day -26：</h3>
<p>csp 初赛，上午考的一脸蒙，下午还好。最后 tg 60多，pj 85.5(非常怀疑去年某培改了分数，因为我去年pj也是 85.5，而那时我还不知道什么是字符串。。。)</p>
<p>zjx 大佬 tg 94，SX 第一，还提前了 半个多小时交卷，这人才初二，这是人干的事？</p>
<h3 id="day-24">day -24：</h3>
<p>zjx 大佬开始集训，连续 20 个下午不上课，然后我们班的管理电脑的人就成我了。</p>
<p>巧合的是，这天 whk 老师因我 whk 考试炸掉而找我谈话，其中一句“发展自己的兴趣前一定要把根本抓好。”似乎是在“建议”我停学 OI，还说我是“25 名的水平考虑 200 名”，让我在期中考“发挥好自己的水平”，我谔谔。</p>
<h3 id="day-22">day -22：</h3>
<p>得知期中考撞上了 csp（其实这句话有误，毕竟期中考在 csp 后2天），郁闷。</p>
<p>经过“慎重”考虑后，我决定全力冲 OI。</p>
<h3 id="day-14">day -14：</h3>
<p>教练定下有过 pj 省一 pj 260 ，无 pj 省一的 pj 省一的要求，pj 260 对于一些大佬或强生的人来说很容易，但对于我确实很难，<s>当时我就想，要知道这我去年 t2 就不写 freopen 了</s></p>
<p>(再次说明：坐标 SX(是 shanxi,!= shaanxi))</p>
<h3 id="day-10">day -10:</h3>
<p>初二体测退后一周至 11.7（== csp），ty 老师要求无论是否补测都要到位，我与老师说 OI 的事，结果。。。</p>
<p><s>还是人太少，</s> 信息（！=OI）老师说有近 40 人会耽误，然后就好了。。。</p>
<h3 id="day-1试机">day -1：试机</h3>
<p>一进考场：<br>
笔……笔记本！？</p>
<p>抬头一看:山西智/创城认证点(((</p>
<p><s>忽然想起 zjx 的“笔记本省选”好像就是在这里。</s></p>
<p>不过性能还好，只是这“ctrl”键。。。</p>
<p>试机时我打了一份位运算 a+b，挂了，后来试了试 hello world，也炸了。</p>
<p>忽然发现这电脑不能同时用 freopen 和 cin 优化。。。</p>
<p>大佬 xty 打了一个输出一堆人 AK 自己爆零的程序，真 fAKe。。。</p>
<p>晚上看到兰州布病爆发的消息，下意识感觉完了。</p>
<p>但看到只有兰州有，而且只有央视新闻发了这个消息，又感觉好了很多。</p>
<p>考前的晚上我一直睡不着，毕竟我太想赢了。</p>
<p><s>当然也可能是睡太早了</s></p>
<h1 id="考时">考时</h1>
<h3 id="day-1-上午pj">day 1 上午，pj：</h3>
<p>一来了考点，就莫名其妙地收到了教练给我们的巧克力</p>
<p>我忽想起小学时的一位演说 <s>传销</s> 家老师说的话</p>
<p>看来考前吃巧克力似乎有一些道理。。。</p>
<p>开考：</p>
<p>先看 t1：</p>
<p>优秀的拆分？这玩意不是道黑体吗？害怕.jpg.png.psd.asdf</p>
<p>看了看题发现不是，但也没什么思路，忽看到<code>可以证明，在规定了拆分数字的顺序后，该拆分方案是唯一的</code>,立刻清醒：</p>
<p>这不就是二进制转换吗？</p>
<p>10 min A了它。</p>
<p>再看 t2：</p>
<p>看了看题发现很简单，吸取上次的教训，我看了看数据范围，然后懵了。</p>
<p><s>十 万 人 同 台 竞 技 N O I，获 奖 概 率 高 达 60% ， 预 计 六 万 人 拿 牌。</s></p>
<p><s>蒟蒻弱弱地问一句：这么多名额，给 SX 多少？</s></p>
<p>开始乱想，sort、插排、二分、倒搜、桶排。</p>
<p>后来想到了堆，发现可以开两个堆（当时脑子糊得厉害，根本没意识到这就是对顶堆）。</p>
<p>30 min，过了大样例。</p>
<p>t3:</p>
<p>想了 30 min ，没思路，20min栈30pts看下一道题。</p>
<p>t4：</p>
<p>我一看这不就是个图论吗？然后使劲想，没想出来。然后神经地用伪证证明它有后效性不能 动态规划。</p>
<p>想了 1h 没思路，20pts深度优先搜索滚回 t3。</p>
<p>然后 t3 还是没思路，不想交卷，坐等15min。</p>
<p>一出去就听见有人说 t4 正解是 动态规划。</p>
<p>我。。。。。</p>
<p>估分：100+100+30+20=250 pts&lt;260pts</p>
<p>暴毙了。。。。。</p>
<p>人陆陆续续地出来，xty 大佬估分 300 ，还有初三大佬估分 365，初一有人估分 300。我。。。。。</p>
<p>难怪有人说 OI 是单调队列，oi 考试是维护单调队列。。。</p>
<p>临走时拍照，大佬们调侃说是&quot;最后的照片&quot;，但这对于我，那时以为似乎并非调侃。</p>
<h2 id="day-1-下午tg">day 1 下午，tg：</h2>
<p>教练说减低难度，如果我们tg拿到260pts也行。</p>
<p><s>这叫降低</s>？</p>
<p>然鹅其实是160pts。。。</p>
<p><s>密码外面还有括号是什么玄学操作</s></p>
<p>t1：</p>
<p><s>看看人家 geergaoli 自动去掉0，再看看洛谷和我们学校的 oj 明天是 csp 结果距离 csp 0天</s></p>
<p><s>zjx:那是向下取整</s></p>
<p><s>我。。。</s></p>
<p>看一眼题：这和 2016 pj-t2 不一样吗？就这？</p>
<p>看一眼数据范围：。。。</p>
<p>想也不想，先暴力，25 min ，过了前两个样例。</p>
<p>然后想到了一种类似跳表的东西，就是一年一年跳，然后一月一月，一天一天，到1582年10月特殊处理。10min写出，调了 15min过了两个样例。</p>
<p>复杂度依然高，我想到可以分段算，[1600,无穷) 二分 ，其余暴力。</p>
<p>然后代码超 200 行，感觉不对，<s>又感觉这么长时间都在写 t1有点给学校丢脸</s>，便去 t2。</p>
<p>t2：</p>
<p>暴力，40pts，10min。</p>
<p>t3：</p>
<p>看了看题，想到了线段树，码了一棵，结果样例都过不了。</p>
<p>然后玩命条，<s>始终没想到回去重新看看题，看错题了嘤嘤嘤。</s></p>
<p>调不出来，造了造数据，都过了，以为数据错了，<s>根本没想到是看错题了</s>，就去 t4。。。</p>
<p>t4：</p>
<p>看一眼题，就发现这是一道博弈论。然鹅我根本不会博弈论。。。</p>
<p>20 pts瞎搞。滚回 t1。</p>
<p>t1：</p>
<p>看了10min，还是没思路。<s>忽想起了“瞎搞出奇迹，偏分最神奇”的“忠告”</s>，瞎搞发现有 80pts，20min去t2。</p>
<p>t2：</p>
<p>忽然反应过来，10min100pts后瞎搞t3t4。</p>
<p>估分：[70,80]+100+[0,10]+[0,20]=[170,210]</p>
<p>出来后发现t4初三高一高二的学长也都不会做，t1会做做不出来，<s>然后一起吐槽t1</s>。</p>
<p>过了一会，zjx 出来了，大家围过去问他t1t4做出来了吗？</p>
<p>然后他居然说做出来了，还说估分 100+100+40+100=340！！！</p>
<p>这是人干的事？</p>
<p>他是不是人无所谓，我当时感觉很好，<strong>以为</strong>不会暴毙了。</p>
<h1 id="赛后">赛后</h1>
<h3 id="1day上午">1day上午：</h3>
<p>没什么事，写了写whk作业。</p>
<h3 id="下午">下午</h3>
<p>2点：我要到了 SX tg的代码，然后决定写完作业自测。</p>
<p>4点：自测。</p>
<p>我先拿出我最有把握的t2，然后兴致勃勃地放到落谷上测，以为会一片 AC，结果是黑绿几乎持平。</p>
<p>心态立刻崩掉。</p>
<p>没信心去测t1t3t4，然而我还是去测了，毕竟还是有侥幸心理。</p>
<p>t1黑绿持平，t3t4全wa或Tle。</p>
<p>这样一来，估分 70+60+0+0=130pts&lt;160pts</p>
<p>无语。。。。。</p>
<h3 id="whk-考试">whk 考试</h3>
<p>希望不要炸掉，希望不要 die of whk。。。</p>
<p>然而炸了。。。</p>
<h3 id="n-days-later">n days later</h3>
<p>最终成绩出来了，</p>
<p>pj=100+100+30+20</p>
<p>tg=70+60+0+20</p>
<p>有人说tgt3线段树能拿 70。</p>
<p>草率了，白白丢了70分。</p>
<p>tgt3的70分啊。/kk</p>
<p>tgt2我开了 ull 了，然而。。。</p>
<p>结果高中生都考的不好，就这成绩还拿了1=和蓝钩。。。</p>
<h3 id="调侃">调侃</h3>
<p>NOIP 5018 后，大家知道卡 int 要用 longlong</p>
<p>csp 5019后，大家知道卡 longlong 要用 ull。</p>
<p>csp 5020后，大家知道卡 ull要特判。</p>
<p>我估计，不出两年，OI一定考高精度，不出5年，一定考 fft。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[差分]]></title>
        <id>https://wyyszl.github.io/post/chai-fen/</id>
        <link href="https://wyyszl.github.io/post/chai-fen/">
        </link>
        <updated>2020-10-20T14:44:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-基础差分">一、基础差分</h2>
<p>1.问题：多次区间修改，一次单点查询<br>
2.思路：对于区间问题，我们可以使用前缀和与线段树。线段树过于复杂，我们可以从前缀和来思考。考虑到每一次单点修改，前缀和都是又该点开始到结尾的区间修改，我们可以将原数组当做某一数组的前缀和，然后对该数组进行两次单点修改，最后再求前缀和即可。<br>
3.由原数组推差分数组：差分是前缀和的逆运算，因而我们应该先知道前缀和公式，易得为：<code>fsum[i]=fsum[i-1]+a[i];</code>，对该等式进行变形，得差分公式：<code>a[i]=fsum[i]-fsum[i-1];</code>，而对于该公式，<code>fsum</code>-&gt;a,<code>cf</code>-&gt;差分数组.<br>
4.结果：求前缀和即为原数组更改后<br>
5.时间复杂度：<code>O(m+n)</code></p>
<h2 id="二-二维差分1">二、二维差分1</h2>
<p>1.思路：将二维拆分为一维<br>
2.时间复杂度:<code>O(mn)</code></p>
<h2 id="二-二维差分2">二、二维差分2</h2>
<p>1.思路：同一维<br>
2.复习二维前缀和：<img src="https://cdn.luogu.com.cn/upload/image_hosting/moezmwuh.png" alt="" loading="lazy"><br>
黄色部分的和即为 fsum[3][3]<br>
公式：<code>fsum[i][j]=fsum[i-1][j]+fsum[i][j-1]-fsum[i-1][j-1]+a[i][j];</code><br>
3.差分公式：<code>cf[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1];</code><br>
4.更改思路：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/jf0wl7ar.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[点名器]]></title>
        <id>https://wyyszl.github.io/post/dian-ming-qi/</id>
        <link href="https://wyyszl.github.io/post/dian-ming-qi/">
        </link>
        <updated>2020-10-18T14:53:33.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="代码">代码</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,k;
string s[64];
string t[15];
string asdf;
int  f[64];
int l=0;
int m;
int main() {
	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
	int*a;
	a=new int [n+1]();
	for(int i=1; i&lt;=m; ++i) {
		cin&gt;&gt;t[i];
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;s[i];
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;a[i];
		a[i] =a[i] bitor 0;
	}
	cin&gt;&gt;asdf;
	for(int i=1; i&lt;=m; ++i) {
		for(int j=1; j&lt;=n; ++j) {
			if(s[j]==t[i]) {
				a[j]=0x3f3f3f3f;
				break;
			}
		}
	}
	srand(time(0));
	for(int i=1; i&lt;=n; ++i) {
		if(a[i]&lt;k){
			f[++l]=i;
		}
	}
	if(not(l))
	cout&lt;&lt;&quot;无结果&quot;;
asdf:
	int tt=rand()%(l+1)+1;
	cout&lt;&lt;s[f[tt]];
	++a[f[tt]];
	freopen(&quot;1.in&quot;,&quot;w&quot;,stdout);
	cout&lt;&lt;n&lt;&lt;' '&lt;&lt;m&lt;&lt;' '&lt;&lt;k&lt;&lt;endl;
	for(int i=1; i&lt;=m; ++i) {
		cout&lt;&lt;t[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	for(int i=1; i&lt;=n; ++i) {
		cout&lt;&lt;s[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	for(int i=1; i&lt;=n; ++i) {
		cout&lt;&lt;a[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl&lt;&lt;s[tt]&lt;&lt;endl;
	for(int i=1; i&lt;=10; ++i)i=sqrt(i);

	return  0;
}
</code></pre>
<h3 id="代码解释">代码解释：</h3>
<p>无<br>
<s>不要问我第 22 行的用处</s></p>
<h3 id="使用方法">使用方法</h3>
<ul>
<li><s>0.编译</s></li>
<li>1.创建一个文本文档名为 1.in</li>
<li>2.在 1.in 中输入以下格式内容：</li>
</ul>
<pre><code>第一行：n(总人数)，m(无需点到的人数)，k(最多次数)
第二行：无需点到的人（用空格隔开）
第三行:名称（用空格隔开）
第四行：n 个 0（用空格隔开）
第五行：任意一个无需点到的名称

</code></pre>
<ul>
<li>3 运行</li>
<li>4 当出现 “无结果时”，至第二部。</li>
</ul>
<h3 id="你可能需要">你可能需要</h3>
<p>链接: https://pan.baidu.com/s/1yK09mb6LmGqgOP4dT4QZEA<br>
提取码: xes9</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="代码">代码</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,k;
string s[64];
string t[15];
string asdf;
int  f[64];
int l=0;
int m;
int main() {
	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
	int*a;
	a=new int [n+1]();
	for(int i=1; i&lt;=m; ++i) {
		cin&gt;&gt;t[i];
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;s[i];
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;a[i];
		a[i] =a[i] bitor 0;
	}
	cin&gt;&gt;asdf;
	for(int i=1; i&lt;=m; ++i) {
		for(int j=1; j&lt;=n; ++j) {
			if(s[j]==t[i]) {
				a[j]=0x3f3f3f3f;
				break;
			}
		}
	}
	srand(time(0));
	for(int i=1; i&lt;=n; ++i) {
		if(a[i]&lt;k){
			f[++l]=i;
		}
	}
	if(not(l))
	cout&lt;&lt;&quot;无结果&quot;;
asdf:
	int tt=rand()%(l+1)+1;
	cout&lt;&lt;s[f[tt]];
	++a[f[tt]];
	freopen(&quot;1.in&quot;,&quot;w&quot;,stdout);
	cout&lt;&lt;n&lt;&lt;' '&lt;&lt;m&lt;&lt;' '&lt;&lt;k&lt;&lt;endl;
	for(int i=1; i&lt;=m; ++i) {
		cout&lt;&lt;t[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	for(int i=1; i&lt;=n; ++i) {
		cout&lt;&lt;s[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	for(int i=1; i&lt;=n; ++i) {
		cout&lt;&lt;a[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl&lt;&lt;s[tt]&lt;&lt;endl;
	for(int i=1; i&lt;=10; ++i)i=sqrt(i);

	return  0;
}
</code></pre>
<h3 id="代码解释">代码解释：</h3>
<p>无<br>
<s>不要问我第 22 行的用处</s></p>
<h3 id="使用方法">使用方法</h3>
<ul>
<li><s>0.编译</s></li>
<li>1.创建一个文本文档名为 1.in</li>
<li>2.在 1.in 中输入以下格式内容：</li>
</ul>
<pre><code>第一行：n(总人数)，m(无需点到的人数)，k(最多次数)
第二行：无需点到的人（用空格隔开）
第三行:名称（用空格隔开）
第四行：n 个 0（用空格隔开）
第五行：任意一个无需点到的名称

</code></pre>
<ul>
<li>3 运行</li>
<li>4 当出现 “无结果时”，至第二部。</li>
</ul>
<h3 id="你可能需要">你可能需要</h3>
<p>链接: https://pan.baidu.com/s/1yK09mb6LmGqgOP4dT4QZEA<br>
提取码: xes9</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 CSP 初赛模拟题及答案]]></title>
        <id>https://wyyszl.github.io/post/2020-csp-chu-sai-mo-ni-ti-ji-da-an/</id>
        <link href="https://wyyszl.github.io/post/2020-csp-chu-sai-mo-ni-ti-ji-da-an/">
        </link>
        <updated>2020-10-09T14:23:25.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://luogu-ipic.oss-cn-shanghai.aliyuncs.com/2020autumn/2020%20%E6%B4%9B%E8%B0%B7%E5%88%9D%E8%B5%9B%E6%A8%A1%E6%8B%9F.pdf">试题</a></p>
<p><a href="https://www.luogu.com.cn/problem/U134036?contestId=34867">提交</a></p>
<p>答案：     ABCBACABCBDBACDFTTTBAFFTTAAFFFTCCCDDACCBDCB</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2758]]></title>
        <id>https://wyyszl.github.io/post/p2758/</id>
        <link href="https://wyyszl.github.io/post/p2758/">
        </link>
        <updated>2020-10-09T14:22:58.000Z</updated>
        <content type="html"><![CDATA[<p>/*<br>
lcs<br>
WA</p>
<p>反例:<br>
abcdf<br>
abdef<br>
*/</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;

char a[2005];
char b[2005];
int f[2005][2005];
int main(){
	ios::sync_with_stdio(0);
	scanf(&quot;%s&quot;,a+1);
	scanf(&quot;%s&quot;,b+1);
	int lena=strlen(a+1);
	int lenb=strlen(b+1);
	for(int i=1;i&lt;=lena;++i){
		for(int j=1;j&lt;=lenb;++j){
			if(not(a[i]-b[j])){
				f[i][j]=f[i-1][j-1]+1;
			}else {
				f[i][j]=max(f[i-1][j],f[i][j-1]);
			}
		}
	}
	cout&lt;&lt;max(lena,lenb)-f[lena][lenb];
	return 0;
}

</code></pre>
<h4 id="正解">正解:</h4>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">;</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mo>=</mo><mi>b</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo><mo>+</mo><mn>1</mn><mo separator="true">;</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(x)=\begin{cases}f[i-1][j-1];&amp;a[i]==b[j]\\min(f[i][j-1],f[i-1][j],f[i-1][j-1])+1;&amp;otherwise\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">;</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">;</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
]]></content>
    </entry>
</feed>