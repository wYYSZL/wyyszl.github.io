<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wyyszl.github.io</id>
    <title>wYYSZL 的博客</title>
    <updated>2021-01-16T12:18:57.285Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wyyszl.github.io"/>
    <link rel="self" href="https://wyyszl.github.io/atom.xml"/>
    <subtitle>祝大家 csp ++score and  ++rp！</subtitle>
    <logo>https://wyyszl.github.io/images/avatar.png</logo>
    <icon>https://wyyszl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, wYYSZL 的博客</rights>
    <entry>
        <title type="html"><![CDATA[csp5020]]></title>
        <id>https://wyyszl.github.io/post/csp5020/</id>
        <link href="https://wyyszl.github.io/post/csp5020/">
        </link>
        <updated>2021-01-16T12:14:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="赛前琐事">赛前琐事：</h1>
<h3 id="day-28">day -28：</h3>
<p>whk 考试，全线炸掉，扎到 200 名。</p>
<h3 id="day-26">day -26：</h3>
<p>csp 初赛，上午考的一脸蒙，下午还好。最后 tg 60多，pj 85.5(非常怀疑去年某培改了分数，因为我去年pj也是 85.5，而那时我还不知道什么是字符串。。。)</p>
<p>zjx 大佬 tg 94，SX 第一，还提前了 半个多小时交卷，这人才初二，这是人干的事？</p>
<h3 id="day-24">day -24：</h3>
<p>zjx 大佬开始集训，连续 20 个下午不上课，然后我们班的管理电脑的人就成我了。</p>
<p>巧合的是，这天 whk 老师因我 whk 考试炸掉而找我谈话，其中一句“发展自己的兴趣前一定要把根本抓好。”似乎是在“建议”我停学 OI，还说我是“25 名的水平考虑 200 名”，让我在期中考“发挥好自己的水平”，我谔谔。</p>
<h3 id="day-22">day -22：</h3>
<p>得知期中考撞上了 csp（其实这句话有误，毕竟期中考在 csp 后2天），郁闷。</p>
<p>经过“慎重”考虑后，我决定全力冲 OI。</p>
<h3 id="day-14">day -14：</h3>
<p>教练定下有过 pj 省一 pj 260 ，无 pj 省一的 pj 省一的要求，pj 260 对于一些大佬或强生的人来说很容易，但对于我确实很难，<s>当时我就想，要知道这我去年 t2 就不写 freopen 了</s></p>
<p>(再次说明：坐标 SX(是 shanxi,!= shaanxi))</p>
<h3 id="day-10">day -10:</h3>
<p>初二体测退后一周至 11.7（== csp），ty 老师要求无论是否补测都要到位，我与老师说 OI 的事，结果。。。</p>
<p><s>还是人太少，</s> 信息（！=OI）老师说有近 40 人会耽误，然后就好了。。。</p>
<h3 id="day-1试机">day -1：试机</h3>
<p>一进考场：<br>
笔……笔记本！？</p>
<p>抬头一看:山西智/创城认证点(((</p>
<p><s>忽然想起 zjx 的“笔记本省选”好像就是在这里。</s></p>
<p>不过性能还好，只是这“ctrl”键。。。</p>
<p>试机时我打了一份位运算 a+b，挂了，后来试了试 hello world，也炸了。</p>
<p>忽然发现这电脑不能同时用 freopen 和 cin 优化。。。</p>
<p>大佬 xty 打了一个输出一堆人 AK 自己爆零的程序，真 fAKe。。。</p>
<p>晚上看到兰州布病爆发的消息，下意识感觉完了。</p>
<p>但看到只有兰州有，而且只有央视新闻发了这个消息，又感觉好了很多。</p>
<p>考前的晚上我一直睡不着，毕竟我太想赢了。</p>
<p><s>当然也可能是睡太早了</s></p>
<h1 id="考时">考时</h1>
<h3 id="day-1-上午pj">day 1 上午，pj：</h3>
<p>一来了考点，就莫名其妙地收到了教练给我们的巧克力</p>
<p>我忽想起小学时的一位演说 <s>传销</s> 家老师说的话</p>
<p>看来考前吃巧克力似乎有一些道理。。。</p>
<p>开考：</p>
<p>先看 t1：</p>
<p>优秀的拆分？这玩意不是道黑体吗？害怕.jpg.png.psd.asdf</p>
<p>看了看题发现不是，但也没什么思路，忽看到<code>可以证明，在规定了拆分数字的顺序后，该拆分方案是唯一的</code>,立刻清醒：</p>
<p>这不就是二进制转换吗？</p>
<p>10 min A了它。</p>
<p>再看 t2：</p>
<p>看了看题发现很简单，吸取上次的教训，我看了看数据范围，然后懵了。</p>
<p><s>十 万 人 同 台 竞 技 N O I，获 奖 概 率 高 达 60% ， 预 计 六 万 人 拿 牌。</s></p>
<p><s>蒟蒻弱弱地问一句：这么多名额，给 SX 多少？</s></p>
<p>开始乱想，sort、插排、二分、倒搜、桶排。</p>
<p>后来想到了堆，发现可以开两个堆（当时脑子糊得厉害，根本没意识到这就是对顶堆）。</p>
<p>30 min，过了大样例。</p>
<p>t3:</p>
<p>想了 30 min ，没思路，20min栈30pts看下一道题。</p>
<p>t4：</p>
<p>我一看这不就是个图论吗？然后使劲想，没想出来。然后神经地用伪证证明它有后效性不能 动态规划。</p>
<p>想了 1h 没思路，20pts深度优先搜索滚回 t3。</p>
<p>然后 t3 还是没思路，不想交卷，坐等15min。</p>
<p>一出去就听见有人说 t4 正解是 动态规划。</p>
<p>我。。。。。</p>
<p>估分：100+100+30+20=250 pts&lt;260pts</p>
<p>暴毙了。。。。。</p>
<p>人陆陆续续地出来，xty 大佬估分 300 ，还有初三大佬估分 365，初一有人估分 300。我。。。。。</p>
<p>难怪有人说 OI 是单调队列，oi 考试是维护单调队列。。。</p>
<p>临走时拍照，大佬们调侃说是&quot;最后的照片&quot;，但这对于我，那时以为似乎并非调侃。</p>
<h2 id="day-1-下午tg">day 1 下午，tg：</h2>
<p>教练说减低难度，如果我们tg拿到260pts也行。</p>
<p><s>这叫降低</s>？</p>
<p>然鹅其实是160pts。。。</p>
<p><s>密码外面还有括号是什么玄学操作</s></p>
<p>t1：</p>
<p><s>看看人家 geergaoli 自动去掉0，再看看洛谷和我们学校的 oj 明天是 csp 结果距离 csp 0天</s></p>
<p><s>zjx:那是向下取整</s></p>
<p><s>我。。。</s></p>
<p>看一眼题：这和 2016 pj-t2 不一样吗？就这？</p>
<p>看一眼数据范围：。。。</p>
<p>想也不想，先暴力，25 min ，过了前两个样例。</p>
<p>然后想到了一种类似跳表的东西，就是一年一年跳，然后一月一月，一天一天，到1582年10月特殊处理。10min写出，调了 15min过了两个样例。</p>
<p>复杂度依然高，我想到可以分段算，[1600,无穷) 二分 ，其余暴力。</p>
<p>然后代码超 200 行，感觉不对，<s>又感觉这么长时间都在写 t1有点给学校丢脸</s>，便去 t2。</p>
<p>t2：</p>
<p>暴力，40pts，10min。</p>
<p>t3：</p>
<p>看了看题，想到了线段树，码了一棵，结果样例都过不了。</p>
<p>然后玩命条，<s>始终没想到回去重新看看题，看错题了嘤嘤嘤。</s></p>
<p>调不出来，造了造数据，都过了，以为数据错了，<s>根本没想到是看错题了</s>，就去 t4。。。</p>
<p>t4：</p>
<p>看一眼题，就发现这是一道博弈论。然鹅我根本不会博弈论。。。</p>
<p>20 pts瞎搞。滚回 t1。</p>
<p>t1：</p>
<p>看了10min，还是没思路。<s>忽想起了“瞎搞出奇迹，偏分最神奇”的“忠告”</s>，瞎搞发现有 80pts，20min去t2。</p>
<p>t2：</p>
<p>忽然反应过来，10min100pts后瞎搞t3t4。</p>
<p>估分：[70,80]+100+[0,10]+[0,20]=[170,210]</p>
<p>出来后发现t4初三高一高二的学长也都不会做，t1会做做不出来，<s>然后一起吐槽t1</s>。</p>
<p>过了一会，zjx 出来了，大家围过去问他t1t4做出来了吗？</p>
<p>然后他居然说做出来了，还说估分 100+100+40+100=340！！！</p>
<p>这是人干的事？</p>
<p>他是不是人无所谓，我当时感觉很好，<strong>以为</strong>不会暴毙了。</p>
<h1 id="赛后">赛后</h1>
<h3 id="1day上午">1day上午：</h3>
<p>没什么事，写了写whk作业。</p>
<h3 id="下午">下午</h3>
<p>2点：我要到了 SX tg的代码，然后决定写完作业自测。</p>
<p>4点：自测。</p>
<p>我先拿出我最有把握的t2，然后兴致勃勃地放到落谷上测，以为会一片 AC，结果是黑绿几乎持平。</p>
<p>心态立刻崩掉。</p>
<p>没信心去测t1t3t4，然而我还是去测了，毕竟还是有侥幸心理。</p>
<p>t1黑绿持平，t3t4全wa或Tle。</p>
<p>这样一来，估分 70+60+0+0=130pts&lt;160pts</p>
<p>无语。。。。。</p>
<h3 id="whk-考试">whk 考试</h3>
<p>希望不要炸掉，希望不要 die of whk。。。</p>
<p>然而炸了。。。</p>
<h3 id="n-days-later">n days later</h3>
<p>最终成绩出来了，</p>
<p>pj=100+100+30+20</p>
<p>tg=70+60+0+20</p>
<p>有人说tgt3线段树能拿 70。</p>
<p>草率了，白白丢了70分。</p>
<p>tgt3的70分啊。/kk</p>
<p>tgt2我开了 ull 了，然而。。。</p>
<p>结果高中生都考的不好，就这成绩还拿了1=和蓝钩。。。</p>
<h3 id="调侃">调侃</h3>
<p>NOIP 5018 后，大家知道卡 int 要用 longlong</p>
<p>csp 5019后，大家知道卡 longlong 要用 ull。</p>
<p>csp 5020后，大家知道卡 ull要特判。</p>
<p>我估计，不出两年，OI一定考高精度，不出5年，一定考 fft。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[差分]]></title>
        <id>https://wyyszl.github.io/post/chai-fen/</id>
        <link href="https://wyyszl.github.io/post/chai-fen/">
        </link>
        <updated>2020-10-20T14:44:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-基础差分">一、基础差分</h2>
<p>1.问题：多次区间修改，一次单点查询<br>
2.思路：对于区间问题，我们可以使用前缀和与线段树。线段树过于复杂，我们可以从前缀和来思考。考虑到每一次单点修改，前缀和都是又该点开始到结尾的区间修改，我们可以将原数组当做某一数组的前缀和，然后对该数组进行两次单点修改，最后再求前缀和即可。<br>
3.由原数组推差分数组：差分是前缀和的逆运算，因而我们应该先知道前缀和公式，易得为：<code>fsum[i]=fsum[i-1]+a[i];</code>，对该等式进行变形，得差分公式：<code>a[i]=fsum[i]-fsum[i-1];</code>，而对于该公式，<code>fsum</code>-&gt;a,<code>cf</code>-&gt;差分数组.<br>
4.结果：求前缀和即为原数组更改后<br>
5.时间复杂度：<code>O(m+n)</code></p>
<h2 id="二-二维差分1">二、二维差分1</h2>
<p>1.思路：将二维拆分为一维<br>
2.时间复杂度:<code>O(mn)</code></p>
<h2 id="二-二维差分2">二、二维差分2</h2>
<p>1.思路：同一维<br>
2.复习二维前缀和：<img src="https://cdn.luogu.com.cn/upload/image_hosting/moezmwuh.png" alt="" loading="lazy"><br>
黄色部分的和即为 fsum[3][3]<br>
公式：<code>fsum[i][j]=fsum[i-1][j]+fsum[i][j-1]-fsum[i-1][j-1]+a[i][j];</code><br>
3.差分公式：<code>cf[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1];</code><br>
4.更改思路：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/jf0wl7ar.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[点名器]]></title>
        <id>https://wyyszl.github.io/post/dian-ming-qi/</id>
        <link href="https://wyyszl.github.io/post/dian-ming-qi/">
        </link>
        <updated>2020-10-18T14:53:33.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="代码">代码</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,k;
string s[64];
string t[15];
string asdf;
int  f[64];
int l=0;
int m;
int main() {
	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
	int*a;
	a=new int [n+1]();
	for(int i=1; i&lt;=m; ++i) {
		cin&gt;&gt;t[i];
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;s[i];
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;a[i];
		a[i] =a[i] bitor 0;
	}
	cin&gt;&gt;asdf;
	for(int i=1; i&lt;=m; ++i) {
		for(int j=1; j&lt;=n; ++j) {
			if(s[j]==t[i]) {
				a[j]=0x3f3f3f3f;
				break;
			}
		}
	}
	srand(time(0));
	for(int i=1; i&lt;=n; ++i) {
		if(a[i]&lt;k){
			f[++l]=i;
		}
	}
	if(not(l))
	cout&lt;&lt;&quot;无结果&quot;;
asdf:
	int tt=rand()%(l+1)+1;
	cout&lt;&lt;s[f[tt]];
	++a[f[tt]];
	freopen(&quot;1.in&quot;,&quot;w&quot;,stdout);
	cout&lt;&lt;n&lt;&lt;' '&lt;&lt;m&lt;&lt;' '&lt;&lt;k&lt;&lt;endl;
	for(int i=1; i&lt;=m; ++i) {
		cout&lt;&lt;t[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	for(int i=1; i&lt;=n; ++i) {
		cout&lt;&lt;s[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	for(int i=1; i&lt;=n; ++i) {
		cout&lt;&lt;a[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl&lt;&lt;s[tt]&lt;&lt;endl;
	for(int i=1; i&lt;=10; ++i)i=sqrt(i);

	return  0;
}
</code></pre>
<h3 id="代码解释">代码解释：</h3>
<p>无<br>
<s>不要问我第 22 行的用处</s></p>
<h3 id="使用方法">使用方法</h3>
<ul>
<li><s>0.编译</s></li>
<li>1.创建一个文本文档名为 1.in</li>
<li>2.在 1.in 中输入以下格式内容：</li>
</ul>
<pre><code>第一行：n(总人数)，m(无需点到的人数)，k(最多次数)
第二行：无需点到的人（用空格隔开）
第三行:名称（用空格隔开）
第四行：n 个 0（用空格隔开）
第五行：任意一个无需点到的名称

</code></pre>
<ul>
<li>3 运行</li>
<li>4 当出现 “无结果时”，至第二部。</li>
</ul>
<h3 id="你可能需要">你可能需要</h3>
<p>链接: https://pan.baidu.com/s/1yK09mb6LmGqgOP4dT4QZEA<br>
提取码: xes9</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="代码">代码</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,k;
string s[64];
string t[15];
string asdf;
int  f[64];
int l=0;
int m;
int main() {
	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
	int*a;
	a=new int [n+1]();
	for(int i=1; i&lt;=m; ++i) {
		cin&gt;&gt;t[i];
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;s[i];
	}
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;a[i];
		a[i] =a[i] bitor 0;
	}
	cin&gt;&gt;asdf;
	for(int i=1; i&lt;=m; ++i) {
		for(int j=1; j&lt;=n; ++j) {
			if(s[j]==t[i]) {
				a[j]=0x3f3f3f3f;
				break;
			}
		}
	}
	srand(time(0));
	for(int i=1; i&lt;=n; ++i) {
		if(a[i]&lt;k){
			f[++l]=i;
		}
	}
	if(not(l))
	cout&lt;&lt;&quot;无结果&quot;;
asdf:
	int tt=rand()%(l+1)+1;
	cout&lt;&lt;s[f[tt]];
	++a[f[tt]];
	freopen(&quot;1.in&quot;,&quot;w&quot;,stdout);
	cout&lt;&lt;n&lt;&lt;' '&lt;&lt;m&lt;&lt;' '&lt;&lt;k&lt;&lt;endl;
	for(int i=1; i&lt;=m; ++i) {
		cout&lt;&lt;t[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	for(int i=1; i&lt;=n; ++i) {
		cout&lt;&lt;s[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	for(int i=1; i&lt;=n; ++i) {
		cout&lt;&lt;a[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl&lt;&lt;s[tt]&lt;&lt;endl;
	for(int i=1; i&lt;=10; ++i)i=sqrt(i);

	return  0;
}
</code></pre>
<h3 id="代码解释">代码解释：</h3>
<p>无<br>
<s>不要问我第 22 行的用处</s></p>
<h3 id="使用方法">使用方法</h3>
<ul>
<li><s>0.编译</s></li>
<li>1.创建一个文本文档名为 1.in</li>
<li>2.在 1.in 中输入以下格式内容：</li>
</ul>
<pre><code>第一行：n(总人数)，m(无需点到的人数)，k(最多次数)
第二行：无需点到的人（用空格隔开）
第三行:名称（用空格隔开）
第四行：n 个 0（用空格隔开）
第五行：任意一个无需点到的名称

</code></pre>
<ul>
<li>3 运行</li>
<li>4 当出现 “无结果时”，至第二部。</li>
</ul>
<h3 id="你可能需要">你可能需要</h3>
<p>链接: https://pan.baidu.com/s/1yK09mb6LmGqgOP4dT4QZEA<br>
提取码: xes9</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 CSP 初赛模拟题及答案]]></title>
        <id>https://wyyszl.github.io/post/2020-csp-chu-sai-mo-ni-ti-ji-da-an/</id>
        <link href="https://wyyszl.github.io/post/2020-csp-chu-sai-mo-ni-ti-ji-da-an/">
        </link>
        <updated>2020-10-09T14:23:25.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://luogu-ipic.oss-cn-shanghai.aliyuncs.com/2020autumn/2020%20%E6%B4%9B%E8%B0%B7%E5%88%9D%E8%B5%9B%E6%A8%A1%E6%8B%9F.pdf">试题</a></p>
<p><a href="https://www.luogu.com.cn/problem/U134036?contestId=34867">提交</a></p>
<p>答案：     ABCBACABCBDBACDFTTTBAFFTTAAFFFTCCCDDACCBDCB</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2758]]></title>
        <id>https://wyyszl.github.io/post/p2758/</id>
        <link href="https://wyyszl.github.io/post/p2758/">
        </link>
        <updated>2020-10-09T14:22:58.000Z</updated>
        <content type="html"><![CDATA[<p>/*<br>
lcs<br>
WA</p>
<p>反例:<br>
abcdf<br>
abdef<br>
*/</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;

char a[2005];
char b[2005];
int f[2005][2005];
int main(){
	ios::sync_with_stdio(0);
	scanf(&quot;%s&quot;,a+1);
	scanf(&quot;%s&quot;,b+1);
	int lena=strlen(a+1);
	int lenb=strlen(b+1);
	for(int i=1;i&lt;=lena;++i){
		for(int j=1;j&lt;=lenb;++j){
			if(not(a[i]-b[j])){
				f[i][j]=f[i-1][j-1]+1;
			}else {
				f[i][j]=max(f[i-1][j],f[i][j-1]);
			}
		}
	}
	cout&lt;&lt;max(lena,lenb)-f[lena][lenb];
	return 0;
}

</code></pre>
<h4 id="正解">正解:</h4>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">;</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mo>=</mo><mi>b</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo><mo>+</mo><mn>1</mn><mo separator="true">;</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(x)=\begin{cases}f[i-1][j-1];&amp;a[i]==b[j]\\min(f[i][j-1],f[i-1][j],f[i-1][j-1])+1;&amp;otherwise\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">;</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">;</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些比较（待完善）]]></title>
        <id>https://wyyszl.github.io/post/yi-xie-bi-jiao-dai-wan-shan/</id>
        <link href="https://wyyszl.github.io/post/yi-xie-bi-jiao-dai-wan-shan/">
        </link>
        <updated>2020-10-09T14:22:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-输入输出比较">一、输入输出比较</h2>
<h4 id="1输入整形以-2147483647-为例">1.输入整形（以 2147483647 为例）</h4>
<ul>
<li>无优化 cin：1 time=0.005684 ms，1 s=175932 times</li>
<li>有优化 cin 1 time=0.001723 ms，1 s=580383 times</li>
<li>scanf：1time=0.002501 ms，1s=399840  times</li>
<li>快读：1time=0.000978ms，1s=1024590 times</li>
</ul>
<h4 id="2输出整形以-2147483647-为例">2.输出整形（以 2147483647 为例）</h4>
<ul>
<li>无优化 cout：1 time=0.001498 ms，1 s=667557 times</li>
<li>有优化 cout：1time=0.001522ms，1 s=657030 times（我感觉加了个假优化(((）</li>
<li>printf ：1 time=0.004952ms，1s=201939 times</li>
<li>快写：1time =0.001519 ms，1s=658328 times（这能叫快写？）</li>
</ul>
<h4 id="3输出字符串10-位">3.输出字符串(10 位)</h4>
<ul>
<li>cout:1time=0.0004658ms,1s = 2146844 times</li>
<li>printf: 1time=0.0038ms,1s= 263157 times</li>
<li>putchar:1time=0.0009758ms,1s= 1024700 times</li>
<li>puts:1time=0.000208 ms,1s= 4807692 times</li>
</ul>
<h4 id="4输出换行">4.输出换行</h4>
<ul>
<li>cout&lt;&lt;'\n':1 time=0.0002811ms,1s= 3557453 times</li>
<li>cout&lt;&lt;endl:1 time=0.002866 ms,1s= 348918 times(同是 cout 生，为何慢 10 倍。。。)</li>
<li>printf：1 time=0.002913 ms,1s= 343289 times</li>
<li>puts:1time=0.0001314 ms,1s= 7610350 times</li>
</ul>
<h2 id="二-i-i">二、++i &amp; i++</h2>
<ul>
<li>++i: 1time=0.000002121 ms,1s= 471475719 times</li>
<li>i++:1time=0.000002473 ms,1s= 404367165 times</li>
</ul>
<h2 id="三-ri-int">三、ri &amp; int</h2>
<ul>
<li>register int: 1time=0.000002121 ms,1s= 471475719 times</li>
<li>int:1 time=0.00000248 ms,1s= 403225806 times</li>
</ul>
<h2 id="四-stl-手写">四、stl &amp; 手写</h2>
<h2 id="五-位运算">五、位运算 &amp; * /</h2>
<h2 id="六-signed-unsigned">六、signed &amp; unsigned</h2>
<h3 id="注所有测试都在性能较差的-windows7-电脑下进行">注：所有测试都在性能较差的 Windows7 电脑下进行</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[花神游历各国]]></title>
        <id>https://wyyszl.github.io/post/hua-shen-you-li-ge-guo/</id>
        <link href="https://wyyszl.github.io/post/hua-shen-you-li-ge-guo/">
        </link>
        <updated>2020-10-09T14:21:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="原题链接"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1550">原题链接</a></h3>
<p>解题思路：<br>
考虑到区间开根号不好维护区间和，即 sum 值不易维护，不能使用延迟标记来区间修改，只能单点修改。单点修改的时间复杂度乍一看是 O(n·m·logn)，但这道题有一定的特征，其特征主要在于开根号的一些特征： \sqrt{1}=1    \sqrt{0}=0。 因而如果一个节点表示的区间都为 1 or 0，那么这个节点和其所有子节点就无需更改。对于每一个非负数，进行数次操作后都可以变为 0 or 1。又因为题目中<code>每个数开平方(下取整)</code>,所以我们对于每一个数仅需要 &lt;= 6 次操作就可以变为 1 or 0 。综上，我们可以把区间修改改为单点修改，搜到一个表示的区间都为 1 or 0 的点就停止操作，而区间查询正常。<br>
解题细节：<br>
1.如何确定一个区间书否都是 1 or 0：打标记或维护最大值（我使用前者，但事实上后者方便一些）。</p>
<h3 id="综上便有了以下错误代码">综上，便有了以下错误代码：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;
int n,m;
int a[100005];
int x,l,r;
struct P{
   int l,r;
   int sum;
   bool flag;
}tree[400050];
void pushup(int t){
   tree[t].sum =tree[t*2].sum +tree[t*2+1].sum ;
   if(tree[t*2].flag and tree[t*2+1].flag )tree[t].flag=1;
   if(tree[t].flag ) tree[t].sum =tree[t].r-tree[t].l+1;
   return;
}
void build(int t,int l,int r){
   tree[t].l =l;
   tree[t].r =r;
   if(l==r){
   	tree[t].sum =a[l];
   	if(l==1)tree[t].flag=1;
   	return;
   }
   int mid=(l+r)/2.0;
   build(t*2,l,mid);
   build(t*2+1,mid+1,r);
   pushup(t);
   return;
}
int qcheck(int t,int l,int r){
   if(l&lt;=tree[t].l and tree[t].r &lt;=r){
   	return tree[t].sum ;
   }
   int mid=(tree[t].l +tree[t].r)/2.0;
   int ans=0;
   if(l&lt;=mid)ans=qcheck(t*2,l,r);
   if(r&gt;mid)ans+=qcheck(t*2+1,l,r);
   return ans;
}
void cnote(int t,int l){
   if(tree[t].l ==tree[t].r ){
   	tree[t].sum =sqrt(tree[t].sum );
   	if(not(tree[t].sum -1) )tree[t].flag=1;
   	return;
   }
   int mid=(tree[t].l +tree[t].r )/2.0;
   if(l&lt;=mid)cnote(t*2,l);
   else cnote(t*2+1,l);
   pushup(t);
   return;
}
int main(){
   ios::sync_with_stdio(0);
   cin&gt;&gt;n;
   for(int i=1;i&lt;=n;++i){
   	cin&gt;&gt;a[i];
   }
   build(1,1,n);
   cin&gt;&gt;m;
   for(int i=1;i&lt;=m;++i){
   	cin&gt;&gt;x&gt;&gt;l&gt;&gt;r;
   	if(not(x-1)){
   		cout&lt;&lt;qcheck(1,l,r)&lt;&lt;endl;;
   	}else{
   		for(int j=l;j&lt;=r;++j){
   			cnote(1,j);
   		}
   	}
   }
   return 0;
}
</code></pre>
<h4 id="tle-20pts">TLE 20pts</h4>
<p>根据上面的分析，该代码的复杂度应该为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>k</mi><mtext> </mtext><mi>m</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(k~m~logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace nobreak"> </span><span class="mord mathdefault">m</span><span class="mspace nobreak"> </span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> ,但该代码在枚举单点修改时复杂度已经达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mtext> </mtext><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n~m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace nobreak"> </span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 。<br>
细节2：单点修改要和区间修改融合而不是直接枚举修改。</p>
<h2 id="错误代码2">错误代码2：</h2>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
int n,m;
int a[100005];
int x,l,r;
struct P {
	int l,r;
	int sum;
	bool flag;
} tree[400050];
void pushup(int t) {
	tree[t].sum =tree[t*2].sum +tree[t*2+1].sum ;
	if(tree[t*2].flag and tree[t*2+1].flag )tree[t].flag=1;
  if(tree[t].flag)tree[t].sum=tree[t].r-tree[t].l+1;
	return;
}
void build(int t,int l,int r) {
	tree[t].l =l;
	tree[t].r =r;
	if(l==r) {
		tree[t].sum =a[l];
		if(a[l]==1 or (not a[l]))tree[t].flag=1;
		return;
	}
	int mid=(l+r)/2.0;
	build(t*2,l,mid);
	build(t*2+1,mid+1,r);
	pushup(t);
	return;
}
int qcheck(int t,int l,int r) {
	if(l&lt;=tree[t].l and tree[t].r &lt;=r) {
		return tree[t].sum ;
	}
	int mid=(tree[t].l +tree[t].r)/2.0;
	int ans=0;
	if(l&lt;=mid)ans=qcheck(t*2,l,r);
	if(r&gt;mid)ans+=qcheck(t*2+1,l,r);
	pushup(t);
	return ans;
}
void cnote(int t,int l,int r) {
	if(tree[t].flag )return;
	if(tree[t].l ==tree[t].r ) {
		tree[t].sum =(int)sqrt(tree[t].sum );
		if(not(tree[t].sum -1) or not(tree[t].sum ))tree[t].flag=1;
		return;
	}
	int mid=(tree[t].l +tree[t].r )/2.0;
	if(l&lt;=mid)cnote(t*2,l,r);
	if(r&gt;mid) cnote(t*2+1,l,r);
	pushup(t);
	return;
}
signed main() {
//	freopen(&quot;11.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;11.out&quot;,&quot;w&quot;,stdout);
    ios::sync_with_stdio(0);
	cin&gt;&gt;n;
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;a[i];
	}
	build(1,1,n);
	cin&gt;&gt;m;
	for(int i=1; i&lt;=m; ++i) {
		cin&gt;&gt;x&gt;&gt;l&gt;&gt;r;
		if(not(x-1)) {
			cout&lt;&lt;qcheck(1,l,r)&lt;&lt;endl;;;;;;;;;
		} else {
			if(l&gt;r){
				l xor_eq r;
				r xor_eq l;
				l xor_eq r;
			}
			cnote(1,l,r);
		}
	}
	return 0;
}
</code></pre>
<p>该代码问题在于这句话：<code>if(tree[t].flag)tree[t].sum=tree[t].r-tree[t].l+1;</code>这行代码忽略了数字为 0 的情况。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>    </mtext></mrow><annotation encoding="application/x-tex">~~~~</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span></span></span></span>细节3：数字可能为 0。</p>
<h2 id="ac-代码">AC 代码：</h2>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
int n,m;
int a[100005];
int x,l,r;
struct P {
	int l,r;
	int sum;
	bool flag;
} tree[400050];
void pushup(int t) {
	tree[t].sum =tree[t*2].sum +tree[t*2+1].sum ;
	if(tree[t*2].flag and tree[t*2+1].flag )tree[t].flag=1;
	return;
}
void build(int t,int l,int r) {
	tree[t].l =l;
	tree[t].r =r;
	if(l==r) {
		tree[t].sum =a[l];
		if(a[l]==1 or (not a[l]))tree[t].flag=1;
		return;
	}
	int mid=(l+r)/2.0;
	build(t*2,l,mid);
	build(t*2+1,mid+1,r);
	pushup(t);
	return;
}
int qcheck(int t,int l,int r) {
	if(l&lt;=tree[t].l and tree[t].r &lt;=r) {
		return tree[t].sum ;
	}
	int mid=(tree[t].l +tree[t].r)/2.0;
	int ans=0;
	if(l&lt;=mid)ans=qcheck(t*2,l,r);
	if(r&gt;mid)ans+=qcheck(t*2+1,l,r);
	pushup(t);
	return ans;
}
void cnote(int t,int l,int r) {
	if(tree[t].flag )return;
	if(tree[t].l ==tree[t].r ) {
		tree[t].sum =(int)sqrt(tree[t].sum );
		if(not(tree[t].sum -1) or not(tree[t].sum ))tree[t].flag=1;
		return;
	}
	int mid=(tree[t].l +tree[t].r )/2.0;
	if(l&lt;=mid)cnote(t*2,l,r);
	if(r&gt;mid) cnote(t*2+1,l,r);
	pushup(t);
	return;
}
signed main() {
//	freopen(&quot;11.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;11.out&quot;,&quot;w&quot;,stdout);
    ios::sync_with_stdio(0);
	cin&gt;&gt;n;
	for(int i=1; i&lt;=n; ++i) {
		cin&gt;&gt;a[i];
	}
	build(1,1,n);
	cin&gt;&gt;m;
	for(int i=1; i&lt;=m; ++i) {
		cin&gt;&gt;x&gt;&gt;l&gt;&gt;r;
        if(l&gt; r) swap(l,r);
		if(not(x-1)) {
			cout&lt;&lt;qcheck(1,l,r)&lt;&lt;endl;;;;;;;;;
		} else {
			cnote(1,l,r);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[模板(待完善)]]></title>
        <id>https://wyyszl.github.io/post/mo-ban-dai-wan-shan/</id>
        <link href="https://wyyszl.github.io/post/mo-ban-dai-wan-shan/">
        </link>
        <updated>2020-10-09T14:21:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c常用模版">C++常用模版</h1>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

class s_r {//快读
	private:
	public:
		inline int read();
};
class s_w {//快写
	private:
	public:
		inline void write(int X);
};
class dfss {//DFS
	private:
		int n;
		int a[25];
		int b[25];
		void dfs(int t);
	public:
		void main();
};
inline int s_r::read() {
	int x=0,f=1;
	char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9') {
		x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
inline void s_w::write(int X) {
	if(X&lt;0) {
		X=~(X-1);
		putchar('-');
	}
	if(X&gt;9) write(X/10);
	putchar(X%10+'0');
	return;
}
void dfss::dfs(int t) {
	if(t==n+1) {
		for(int i=1; i&lt;=n; ++i) {
			cout&lt;&lt;a[i]&lt;&lt;' ';
		}
		cout&lt;&lt;endl;
		return ;
	}
	for(int i=1; i&lt;=n; ++i) {
		if(!b[i]) {
			b[i]=1;
			a[t]=i;
			dfs(t+1);
			b[i]=0;
		}
	}
	return ;
}
void dfss::main () {
	cin&gt;&gt;n;
	dfs(1);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我们为什么不留下东西]]></title>
        <id>https://wyyszl.github.io/post/wo-men-wei-shi-me-bu-liu-xia-dong-xi/</id>
        <link href="https://wyyszl.github.io/post/wo-men-wei-shi-me-bu-liu-xia-dong-xi/">
        </link>
        <updated>2020-10-09T14:20:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="here-are-the-reasons">here are the reasons：</h1>
<p>1.这个家伙很懒，什么也没有留下<br>
2.这个家伙一点也不懒，可还是什么也没有留下<br>
3.这个家伙很菜，什么也留不下<br>
4.这个家伙刷题去了，什么也没有留下<br>
5.这个人很笨，什么也没有留下<br>
6.这个家伙不知怎么样，总之什么也没有留下<br>
7.这个家伙死了，什么也没有留下<br>
8.这个家伙超可爱，什么也没有留下<br>
9.这个家伙在吃饭，什么东西也没有留下<br>
10.这条家伙很闲，但是还是什么也留不下<br>
11.这个家伙就是很懒，所以什么也没有留下<br>
12.这个家伙是超级灰名，所以没有权利留下任何东西</p>
<h1 id="欢迎补充">欢迎补充</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对数优化dij]]></title>
        <id>https://wyyszl.github.io/post/dui-shu-you-hua-dij/</id>
        <link href="https://wyyszl.github.io/post/dui-shu-you-hua-dij/">
        </link>
        <updated>2020-10-09T14:19:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1复习邻接表">1.复习邻接表</h1>
<p>链表结构，将每个点x出发的邻边链起来，用hd[x]记录每个条边的编号，说明这些边号是与x相关的。<br>
链表：<br>
原型：</p>
<pre><code class="language-cpp">struct P{
	int to,nxt,dis;
}line[MAXM]//如果是无向图，数组大小为MAXN*2

</code></pre>
<p>初始化：</p>
<pre><code class="language-cpp">	memset(hd,-1,sieof hd);
	num=0;
</code></pre>
<p>添加：</p>
<pre><code class="language-cpp">void add(int x,int y,int z){//x到y有距离为z的单向边(数列前向星)
	num++;
	line[num].dis = z;
	line[num].nxt = hd[x];
	line[num].to  = y;
	hd[x]=num;
}
</code></pre>
<p>遍历：</p>
<pre><code class="language-cpp">for(int i=hd[u];i!=-1;i=line[i].nxt){
	...
}
</code></pre>
<h1 id="2复习堆">2.复习堆</h1>
<ol>
<li>定义：priority_queue<int>dl;<br>
整型优先队列。<br>
默认大根堆</li>
<li>相关语法：</li>
</ol>
<pre><code class="language-cpp">dl.push(...);   
...=dl.top();   
dl.pop();   
dl.empty();   
dl.size();  
</code></pre>
<ol start="3">
<li>堆排序</li>
</ol>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
priority_queue &lt;int&gt; q;
int x;
int main(){
int n;scanf(&quot;%d&quot;,&amp;n);
for(int i=1;i&lt;=n;i++){
  scanf(&quot;%d&quot;,&amp;x);
  q.push(x);
}
for(int i=1;i&lt;=n;i++){
  printf(&quot;%d &quot;,q.top());
  q.pop();
}
}

</code></pre>
<p>4.大变小</p>
<pre><code class="language-cpp">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; dl; 
  
</code></pre>
<p>0</p>
<pre><code class="language-cpp">bool operator &lt; (const Node&amp; x)const{
  return dis &gt; x.dis;
}
</code></pre>
<h1 id="3dij">3.dij</h1>
<p>1.基于贪心的想法<br>
2.以1为起点，所有点当中一定至少可以确定一条最短路，即这条最短路不会被其他点再次更新。</p>
<p>3.之后又会诞生至少一条最短路，用其更新别的点，此后所有边中一定又会诞生出一条最短路</p>
<p>4.以此类推</p>
<h1 id="堆优化">堆优化</h1>
<p>因为每次都找已经是最短路的点，考虑用堆实现，o(n)-&gt;o(logn)<br>
每次找已经是最短路的一点，去更新他点(松弛)<br>
但是考虑一个点会被多次更新，入堆，因此堆中会存留不是最短路的点。而这个点一旦松弛完别人它的使命就结束了。堆中他的 “余党”就不能松弛别人了。</p>
<h3 id="板子">板子</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;
int num;
int n,m,s;
int x,y,z;
int dis[100005],vis[100005];
int hd[100005];
struct P{
  int dis,to,nxt;
}line[200005];
void add(int x,int y,int z){
  num++;
  line[num].dis =z;
  line[num].nxt =hd[x];
  line[num].to =y;
  hd[x]=num;
}
struct Node{
  int id,dis;
  bool operator &lt; (const Node&amp; x)const{
  	return dis &gt; x.dis ;
  }
  Node(){}
  Node(int x,int y){id=x,dis=y;}
};
priority_queue&lt;Node&gt; dl;
void dij(){
  while(!dl.empty()){
  	Node l=dl.top();
  	dl.pop();
  	int u=l.id ,v=l.dis ;
  	if(vis[u])continue;
  	vis[u]=1;
  	for(int i=hd[u];i!=-1;i=line[i].nxt ){
  		if(dis[line[i].to ]&gt;dis[u]+line[i].dis ){
  			dis[line[i].to ]=dis[u]+line[i].dis;
  			dl.push(Node(line[i].to ,dis[line[i].to ]));
  		}
  	}
  }
}
int main() {
  cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
  memset(hd,-1,sizeof hd);
  for(int i=1;i&lt;=m;i++){
  	cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
  	add(x,y,z);
  }
  memset(dis,0x3f,sizeof dis);
  dis[s]=0;
  dl.push(Node(s,0));
  dij();
  for(int i=1;i&lt;=n;i++){
  	cout&lt;&lt;dis[i]&lt;&lt;' ';
  }
  return 0;
}


</code></pre>
]]></content>
    </entry>
</feed>